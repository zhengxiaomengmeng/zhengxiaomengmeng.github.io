<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.54.0 with theme Tranquilpeak 0.4.3-SNAPSHOT">
<meta name="author" content="Dream">
<meta name="keywords" content=", JavaScript, CSS, HTML">
<meta name="description" content="通信类 问题提出 题目: 通信类问题
分析过程 需要掌握得知识点
 什么是同源策略及限制
 前后端如何通信
 如何创建Ajax
 跨域通信的几种方式
  1.什么是同源策略及限制
 1.同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。 ( 这是一个用于隔离潜在恶意文件的关键的安全机制。) 2.一个源包括：协议、域名、端口 （这三个有一个不一样就是源不一样，就是我们所说的跨域了） http:// 协议 www.xxx.com 域名 没指名端口默认80 3.限制：不是一个源的文档没有权利去操作另一个源的文档；
 主要限制在几个方面：
 Cookie、LocalStorage 和 IndexDB 无法读取 &ndash;操作不了Cookie、LocalStorage、IndexDB
 DOM无法获得 &ndash;无法获取和操作另一个资源的DOM
 Ajax请求不能发送（同源下的通信方式） &ndash;Ajax只适合同源的通信（跨域就不行了）
  2.前后端如何通信
 1、Ajax &ndash;同源下的通信方式 2、WebSocket &ndash;不受同源策略的限制 3、CORS &ndash;支持跨域通信，也支持同源通信
 3.如何创建Ajax
 1、XMLHttpRequest对象的工作流程 2、兼容性处理 3、事件的触发条件 4、事件的触发顺序
  function ajax(url,fnSucc,fnFaild){ //1、创建一个对象（兼容IE6写法） var xhr = XMLHttpRequest ?">


<meta property="og:description" content="通信类 问题提出 题目: 通信类问题
分析过程 需要掌握得知识点
 什么是同源策略及限制
 前后端如何通信
 如何创建Ajax
 跨域通信的几种方式
  1.什么是同源策略及限制
 1.同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。 ( 这是一个用于隔离潜在恶意文件的关键的安全机制。) 2.一个源包括：协议、域名、端口 （这三个有一个不一样就是源不一样，就是我们所说的跨域了） http:// 协议 www.xxx.com 域名 没指名端口默认80 3.限制：不是一个源的文档没有权利去操作另一个源的文档；
 主要限制在几个方面：
 Cookie、LocalStorage 和 IndexDB 无法读取 &ndash;操作不了Cookie、LocalStorage、IndexDB
 DOM无法获得 &ndash;无法获取和操作另一个资源的DOM
 Ajax请求不能发送（同源下的通信方式） &ndash;Ajax只适合同源的通信（跨域就不行了）
  2.前后端如何通信
 1、Ajax &ndash;同源下的通信方式 2、WebSocket &ndash;不受同源策略的限制 3、CORS &ndash;支持跨域通信，也支持同源通信
 3.如何创建Ajax
 1、XMLHttpRequest对象的工作流程 2、兼容性处理 3、事件的触发条件 4、事件的触发顺序
  function ajax(url,fnSucc,fnFaild){ //1、创建一个对象（兼容IE6写法） var xhr = XMLHttpRequest ?">
<meta property="og:type" content="article">
<meta property="og:title" content="通信类">
<meta name="twitter:title" content="通信类">
<meta property="og:url" content="https://zhengxiaomengmeng.github.io/2019/04/%E9%80%9A%E4%BF%A1%E7%B1%BB/">
<meta property="twitter:url" content="https://zhengxiaomengmeng.github.io/2019/04/%E9%80%9A%E4%BF%A1%E7%B1%BB/">
<meta property="og:site_name" content="Welcome to Dream&#39;s blog ">
<meta property="og:description" content="通信类 问题提出 题目: 通信类问题
分析过程 需要掌握得知识点
 什么是同源策略及限制
 前后端如何通信
 如何创建Ajax
 跨域通信的几种方式
  1.什么是同源策略及限制
 1.同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。 ( 这是一个用于隔离潜在恶意文件的关键的安全机制。) 2.一个源包括：协议、域名、端口 （这三个有一个不一样就是源不一样，就是我们所说的跨域了） http:// 协议 www.xxx.com 域名 没指名端口默认80 3.限制：不是一个源的文档没有权利去操作另一个源的文档；
 主要限制在几个方面：
 Cookie、LocalStorage 和 IndexDB 无法读取 &ndash;操作不了Cookie、LocalStorage、IndexDB
 DOM无法获得 &ndash;无法获取和操作另一个资源的DOM
 Ajax请求不能发送（同源下的通信方式） &ndash;Ajax只适合同源的通信（跨域就不行了）
  2.前后端如何通信
 1、Ajax &ndash;同源下的通信方式 2、WebSocket &ndash;不受同源策略的限制 3、CORS &ndash;支持跨域通信，也支持同源通信
 3.如何创建Ajax
 1、XMLHttpRequest对象的工作流程 2、兼容性处理 3、事件的触发条件 4、事件的触发顺序
  function ajax(url,fnSucc,fnFaild){ //1、创建一个对象（兼容IE6写法） var xhr = XMLHttpRequest ?">
<meta name="twitter:description" content="通信类 问题提出 题目: 通信类问题
分析过程 需要掌握得知识点
 什么是同源策略及限制
 前后端如何通信
 如何创建Ajax
 跨域通信的几种方式
  1.什么是同源策略及限制
 1.同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。 ( 这是一个用于隔离潜在恶意文件的关键的安全机制。) 2.一个源包括：协议、域名、端口 （这三个有一个不一样就是源不一样，就是我们所说的跨域了） http:// 协议 www.xxx.com 域名 没指名端口默认80 3.限制：不是一个源的文档没有权利去操作另一个源的文档；
 主要限制在几个方面：
 Cookie、LocalStorage 和 IndexDB 无法读取 &ndash;操作不了Cookie、LocalStorage、IndexDB
 DOM无法获得 &ndash;无法获取和操作另一个资源的DOM
 Ajax请求不能发送（同源下的通信方式） &ndash;Ajax只适合同源的通信（跨域就不行了）
  2.前后端如何通信
 1、Ajax &ndash;同源下的通信方式 2、WebSocket &ndash;不受同源策略的限制 3、CORS &ndash;支持跨域通信，也支持同源通信
 3.如何创建Ajax
 1、XMLHttpRequest对象的工作流程 2、兼容性处理 3、事件的触发条件 4、事件的触发顺序
  function ajax(url,fnSucc,fnFaild){ //1、创建一个对象（兼容IE6写法） var xhr = XMLHttpRequest ?">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2019-04-27T13:41:44">
  
  
    <meta property="article:modified_time" content="2019-04-27T13:41:44">
  
  
  
    
      <meta property="article:section" content="JavaScript学习笔记">
    
  
  
    
      <meta property="article:tag" content="JavaScript">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15578035-30911da9c83ed8b1.jpg">
  <meta property="twitter:image" content="https://upload-images.jianshu.io/upload_images/15578035-30911da9c83ed8b1.jpg">


    <title>通信类</title>

    <link rel="icon" href="https://zhengxiaomengmeng.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://zhengxiaomengmeng.github.io/2019/04/%E9%80%9A%E4%BF%A1%E7%B1%BB/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />

    
    
    <link rel="stylesheet" href="https://zhengxiaomengmeng.github.io/css/style-nnm2spxvve8onlujjlegkkytaehyadd4ksxc1hyzzq9a2wvtrgbljqyulomn.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://zhengxiaomengmeng.github.io/">Welcome to Dream&#39;s blog </a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://zhengxiaomengmeng.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://upload-images.jianshu.io/upload_images/15578035-30911da9c83ed8b1.jpg" alt="作者的图片" />
      
    
    </a>
  
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://zhengxiaomengmeng.github.io/#about">
          <img class="sidebar-profile-picture" src="https://upload-images.jianshu.io/upload_images/15578035-30911da9c83ed8b1.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">Dream</h4>
        
          <h5 class="sidebar-profile-bio">It is better to be clear than to be clever.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://zhengxiaomengmeng.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://zhengxiaomengmeng.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://zhengxiaomengmeng.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://zhengxiaomengmeng.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://zhengxiaomengmeng.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/zhengxiaomengmeng" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      通信类
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-04-27T13:41:44&#43;08:00">
        
  
  
  
  
    2019-04-27
  

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://zhengxiaomengmeng.github.io/categories/javascript%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0">JavaScript学习笔记</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              

<h2 id="通信类">通信类</h2>

<h3 id="问题提出">问题提出</h3>

<p><strong>题目</strong>: 通信类问题</p>

<h3 id="分析过程">分析过程</h3>

<p><strong>需要掌握得知识点</strong></p>

<ul>
<li><p>什么是同源策略及限制</p></li>

<li><p>前后端如何通信</p></li>

<li><p>如何创建Ajax</p></li>

<li><p>跨域通信的几种方式</p></li>
</ul>

<p>1.什么是同源策略及限制</p>

<blockquote>
<p><strong>1.同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。</strong> ( 这是一个<strong>用于隔离潜在恶意文件的关键的安全机制。</strong>)
2.一个源包括：<strong>协议、域名、端口</strong>
（这三个有一个不一样就是源不一样，就是我们所说的跨域了）
http:// 协议
www.xxx.com 域名
没指名端口默认80
3.限制：不是一个源的文档没有权利去操作另一个源的文档；</p>
</blockquote>

<p><strong>主要限制在几个方面：</strong></p>

<ul>
<li><p>Cookie、LocalStorage 和 IndexDB 无法读取
&ndash;操作不了Cookie、LocalStorage、IndexDB</p></li>

<li><p>DOM无法获得
&ndash;无法获取和操作另一个资源的DOM</p></li>

<li><p>Ajax请求不能发送（同源下的通信方式）
&ndash;Ajax只适合同源的通信（跨域就不行了）</p></li>
</ul>

<p><strong>2.前后端如何通信</strong></p>

<blockquote>
<p>1、Ajax
&ndash;同源下的通信方式
2、WebSocket
&ndash;不受同源策略的限制
3、CORS
&ndash;支持跨域通信，也支持同源通信</p>
</blockquote>

<p><strong>3.如何创建Ajax</strong></p>

<blockquote>
<p>1、XMLHttpRequest对象的工作流程
2、兼容性处理
3、事件的触发条件
4、事件的触发顺序</p>
</blockquote>

<pre><code> function ajax(url,fnSucc,fnFaild){
    
   //1、创建一个对象（兼容IE6写法）
    var xhr = XMLHttpRequest ? new XMLHttpRequest(): new ActiveXObject('Microsoft.XMLHTTP');
    
    //2、连接服务器，确定对象的发送方式：xhr.open(type,url,true);
    xhr.open('GET',url,true);
    
    //3、发送请求
    xhr.send();

    //4、接受服务器返回（响应）
    xhr.onreadyStateChange = function(){
    
        if(xhr.readyState == 4){//完成
            
 //如果加载媒体资源需要再加上xhr.status===206
(媒体资源特别大，不是一次性返回过来的，是资源的一部分；服务端给你下发的http状态码是206，
 这个地方不加206，是收不到响应的)
            
            if (xhr.status === 200 || xhr.status === 304) {
                fuSucc(xhr.responseText);
            }else{
               if(fnFaild){
                 fnFaild(xhr.status);
               }
            }
        }
        
    };
}
</code></pre>

<p><strong>4.跨域通信的几种方式</strong></p>

<ul>
<li>JSONP</li>
</ul>

<pre><code>     1.在什么时候用：
     --在出现postMessage、CORS之前一直用JSONP做跨域通信的；
     2.怎么做到的：
       -- 利用script标签的异步加载来实现的；
     （一个页面是www.immoc.com，script标签地址的域名100%不是（js的地址和域名是不一致的），
       跨源了，不影响script加载）--这就是jsonp能够实行的一个最初的基本原理；
                    
     3.怎么实现的：
     --需要给服务端传递一个回调的名，这个回调的名就是我用加载script标签的方式发出一个请求去，
    你给我返回一块内容，这个内容是一个js块也就是script的块，这个块中有回调名加代码就能运行了，
            
    --原理:（利用这个发出请求了,告诉服务端callback的名称，将来要作为函数名来返回的，既然是函数名,
要创建一个函数，所以在调jsonp的时候 ，本地必须有一个jsonp的这么全局函数，后面才能把给的数据能
执行出来，当函数来运行。）
            
  callback后面名字叫什么都可以； 
  &lt;script src=&quot;http://www.abc.com/?data=name&amp;callback=jsonp&quot;&gt;&lt;/script&gt;
        
-告诉它一个回调的名称,而且要在window注册一个全局的一个函数，然后下面的createScript就是要动
态创建一个script标签，最后返回这个东西。最后script.onload是监听脚本的加载事件，如果响应完了,
也会响应onload，然后判断onload是不是成功，成功了以后看能不能拿到那个数据。最后不要忘了删除这
个函数变量window[callbackName]=null;最后往html中增加script标签目的就是把这个请求发送出去。
        
        
3.1.1.服务器给你下发的是一个script内容，利用回调的东西，执行了后面的代码
        &lt;script&gt;
            jsonp({
                data:{
                }
            });
        &lt;/script&gt;
        
        jsonp.js:
        box({name:'xxx'});
        
        function createJs(sUrl){
            var oScript = document.createElement('script');
            oScript.type = &quot;text/javascript&quot;;
            oScript.src = sUrl;
            document.getElementsByTagName('head')[0].appendChild(oScript);
        }
        
        createJs('jsonp.js?callback=box');
        
        function box(json){
            alert(json.name);
        }
</code></pre>

<ul>
<li>Hash（url地址中#后面的东西）</li>
</ul>

<pre><code>   --Hash的变动页面不会刷新
       url中?后面的叫search：search的改变是会刷新页面的；所以search不能做跨域通信；
    
      // 利用hash，场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B，跨域给B发消息
      
      // 在A中伪代码如下：
      var B = document.getElementsByTagName('iframe');
      B.src = B.src + '#' + 'data';
      
      // 在B中的伪代码如下
      window.onhashchange = function () {
          var data = window.location.hash;
      };
      
      **跨域给B发消息：
      先拿到B这个窗口的地址src，然后通过hash的方式后面发一段字符串，这个字符串可以是通过完整的json，最后通过json.stringify()把json转成字符串发给B，你是发出去了，B能不能接收到，B在自己的代码中增加一个window.onhashchange,这个事件是用来监听你当前页面的hash有没有改变。之前的页面是src，现在的页面加一个hash，所以对B来说，你的url的hash变化了，就可以拿到了。拿到了以后通过window.location.hash就能拿到hash的具体内容。
      window.location.hash可不是拿到一个，如果hash后面等于data除了A发送过来的东西还有别的拼接，回来要特殊处理一下。
</code></pre>

<ul>
<li>postMessage（html5新增加的处理跨域通信的）</li>
</ul>

<pre><code>        同源策略的目标就是限制跨域通信，但是实际业务中又需要跨域通信；
        html5中出现了这个标准postMessage，用这个实现跨域通信；
        
          // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
          Bwindow.postMessage('data', 'http://B.com');
          // 在窗口B中监听
          Awindow.addEventListener('message', function (event) {
              console.log(event.origin);
              console.log(event.source);
              console.log(event.data);
          }, false);
          
        **怎么发送：
       在A窗口，给谁发送，要选中哪个窗口，调postMessage这个API，第一个参数是发送的数据部分，这里推荐使用字符串格式；第二个是接收方那个源，*是可以给任何窗口发送（很多窗口都能接收到你的信息，这个是不安全的），推荐的做法是加上一个源；

        **发送对方怎么接受：
            B窗口要做哪些事情呢？
            就是要监听message事件，
            window.addEventListener('message',响应函数，true/false指定捕获还是冒泡);
            要拿的就是下面这三个参数：
            //来判断发送者的源，在你的响应程序中，你要选择性的接收；比如我只接收来自A.com的
            信息，其他的一律不接收，那么就通过event.origin这个属性来判断
              console.log(event.origin);
              console.log(event.source);//引用A窗口的对象
              console.log(event.data);//发送的消息通过event.data拿到数据
</code></pre>

<ul>
<li>WebSocket（不受同源策略限制的，拿来跨域通信正合适）</li>
</ul>

<pre><code>          1.声明一个webSocket对象，这个地方有两种，ws、wss区别一个加密一个非加密，
           后面指向服务器的一个地址，这样就建立了相当于JS一个对象来管理这个链接。
          var ws = new WebSocket('wss://echo.websocket.org');
    
           2.请求发送出去
          ws.onopen = function (evt) {
              console.log('Connection open ...');
              ws.send('Hello WebSockets!');
          };
    
           3.对方给消息怎么接收，通过这个参数的data来拿到
          ws.onmessage = function (evt) {
              console.log('Received Message: ', evt.data);
              ws.close();
          };
    
          4.最后这个链接不用了，中断了，监听onclose来确定是不是关闭了
          ws.onclose = function (evt) {
              console.log('Connection closed.');
          };
</code></pre>

<ul>
<li>CORS（Ajax一个变种，fetch实现CORS通信的&ndash;新出的通信标准，可以理解为支持跨域通信的Ajax）</li>
</ul>

<pre><code>
    Ajax是不能发送跨域通信的，浏览器在识别你用Ajax发送了一个跨域请求的时候，它会在你http头中加一个orgin，来允许跨域通信。如果不加这个头，就是一个普通的Ajax，遇到跨域通信，浏览器就会拦截了（非法的不允许请求）。
         
  // url（必选），options（可选），then就是回调成功，回调类似ES6的promise的写法；
     catch就是捕获错误。
          
          fetch('/some/url/', {
              method: 'get',
              }).then(function (response) {
    
                 }).catch(function (err) {
            // 出错了，等价于 then 的第二个参数，但这样更好用更直观
          });
          
    *CROS为什么就能支持跨域的这种通信？   
    浏览器会拦截ajax请求，如果它觉得这个ajax请求是跨域的，它会在http请求头中，加一个origin
</code></pre>

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://zhengxiaomengmeng.github.io/tags/javascript/">JavaScript</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://zhengxiaomengmeng.github.io/2019/04/%E5%AE%89%E5%85%A8%E7%B1%BB/" data-tooltip="安全类">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://zhengxiaomengmeng.github.io/2019/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-tooltip="面向对象">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://zhengxiaomengmeng.github.io/2019/04/%E9%80%9A%E4%BF%A1%E7%B1%BB/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
			
          </div>
		 
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 Dream. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://zhengxiaomengmeng.github.io/2019/04/%E5%AE%89%E5%85%A8%E7%B1%BB/" data-tooltip="安全类">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://zhengxiaomengmeng.github.io/2019/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-tooltip="面向对象">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://zhengxiaomengmeng.github.io/2019/04/%E9%80%9A%E4%BF%A1%E7%B1%BB/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3A%2F%2Fzhengxiaomengmeng.github.io%2F2019%2F04%2F%25E9%2580%259A%25E4%25BF%25A1%25E7%25B1%25BB%2F">
          <i class="fa fa-google-plus"></i><span>分享到 Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://upload-images.jianshu.io/upload_images/15578035-30911da9c83ed8b1.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">Dream</h4>
    
      <div id="about-card-bio">It is better to be clear than to be clever.</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        学生
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        中国-浙江
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="搜索" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/05/%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%87%BD%E6%95%B0/">
                <h3 class="media-heading">通用的事件侦听函数</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">通用的事件侦听函数 分析过程 需要考虑的问题如下几点：
 页面是否加载完成
 增加移除事件：DOM等级和不同浏览器之间的兼容性
 取消默认行为、阻止默认行为
 获取事件目标
  代码实现 //写一个通用的事件监听函数 markyun.Event = { //页面加载完成后 readyEvent: function (fn) { if (fn == null) { fn = document; } var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = fn; } else { window.onload = function () { oldonload(); fn(); } } }, //分别使用dom0，dom2或IE方式来绑定事件 //参数：操作的元素、事件名称、事件处理程序 addEvent: function (element, type, handler) { if (element.addEventListener) { element.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/05/mock%E6%95%B0%E6%8D%AE/">
                <h3 class="media-heading">Mock数据</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Vue-cli 本地开发mock数据使用方法 参考博客： vue-cli 本地开发mock数据使用方法</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/05/proxytable-%E8%A7%A3%E5%86%B3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">
                <h3 class="media-heading">ProxyTable 解决开发环境的跨域问题</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Vue-cli中的proxyTable解决开发环境的跨域问题  对于前端开发人员来讲，当你在开发环境中与后台开发人员进行数据联调时，总会遇到烦人的跨域问题！
 解决跨域的方法有很多种，比如你和后台人员经过友好协商后，你可以通过JSONP的方式或者让后台人员将代码设置为允许你进行跨域！但是往往前后台开发人员的配合默契度是不太高的。如果后台只给你接口，并明确告诉你不允许修改接口，怎么办？怎么办才能实现跨域？此时你就可以通过proxyTable来解决跨域问题！
 通过proxyTable解决跨域在Vue-cli当中是很简单的。只需修改config文件夹下的index.js中的proxyTable就能实现：
 //代理配置表，在这里可以配置特定的请求代理到对应的API接口 proxyTable:{ &quot;/api&quot;:{ target:&quot;http://www.xxx.com&quot;, //访问的服务器地址 changeOrigin:true, //true为开启代理 //secure: true, // 如果是https接口，需要配置这个参数 pathRewrite:{ '^/api': '/' //路径的替换规则 /* *这里的配置是正则表达式，以/api开头的路径将会被‘/'替换掉 *假如后台文档的接口是 &quot;http://www.xxx.com/user/add&quot; *前端调取API接口应写：axios.get('/api/user/add') */ } } }   以上代码的“/api”你可以认为用于代替target里面的地址，调取接口的地址直接用api来替换。
比如后台接口地址为：”http://www.xxx.com/user/login“。 你可以直接写为：”/api/user/login”即可。
 可以根据不同的API域名负责的模块不同来进行多项配置
//代理配置表，在这里可以配置特定的请求代理到对应的API接口 proxyTable:{ &quot;/adv&quot;:{ target:&quot;http://adv.com&quot;,//访问的服务器地址 changeOrigin:true,//true为开启代理 pathRewrite:{ '^/adv': '/'//路径的替换规则 } }， &quot;/user&quot;:{ target:&quot;http://user.com&quot;,//访问的服务器地址 changeOrigin:true,//true为开启代理 pathRewrite:{ '^/user': '/'//路径的替换规则 } } }   以上代码”/adv”与”/user”分别负责项目中的广告模块与用户模块。 例如： 后台文档的地址是：“http://adv.com/add”， 前端调取API接口应写：axios.get(‘/adv/add’)
 注意： 配置修改完以后一定要重新npm run dev 一次</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/05/set%E5%92%8Cmap/">
                <h3 class="media-heading">Set和Map</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Set ES6提供了新的数据结构Set。类似于数组，只不过其成员值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。
var s = new Set(); // 通过add方法向Set结构中加入成员 [2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x)) for (i of s) { console.log(i) } // 2 3 4 5 （表明set结构不会添加重复的值）   Set结构接收一个数组作为参数，用来初始化。
 var items = new Set([1, 2, 3, 4, 5, 5, 5]); items.size // 5   向Set加入值的时候，不会发生类型转换。这意味着，在Set中5和”5”是两个不同的值。
 Set结构有以下属性：  Set.prototype.constructor: 构造函数，默认就是Set函数。 Set.prototype.size : 返回Set的成员总数。
 Set结构有以下属性：  add(value) : 添加某个值。 delete(value) : 删除某个值。 has(value) : 返回一个布尔值，表示该值是否为Set的成员。 clear() : 清除所有成员。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/05/%E9%A1%B5%E9%9D%A2%E6%94%BE%E5%A4%A7%E7%BC%A9%E5%B0%8F%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E5%85%B6%E5%AE%BD%E9%AB%98%E6%AF%94%E4%BE%8B%E4%B8%8D%E5%8F%98/">
                <h3 class="media-heading">页面放大缩小如何保持其宽高比例不变</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">页面放大缩小如何保持其宽高比例不变 解决方案  使用响应式来做，根据媒体查询，设定在不同屏幕宽度下div的高度和宽度
 使用padding-bottom：XX%大法实现（定义基于父元素宽度的百分比下内边距。此值不会如预期地那样工作于所有的浏览器中。）
 使用vw属性
  实现方案  媒体查询
@media only screen and (min-width: 100px) and (max-width: 640px) { div{ width: 100px; height: 100px; } } @media only screen and (min-width: 641px) and (max-width: 789px) { div{ width: 200px; height: 200px; } }  padding-bottom：XX%大法
  &lt;body&gt; &lt;style&gt; .inner { height: 0; padding-bottom: 25%; overflow: hidden; background-color: red; } &lt;/style&gt; &lt;div style=&quot;width: 50%;&quot;&gt; &lt;div class=&quot;inner&quot;&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; 测试&lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;   使用vw属性，他是参考整个viewport（视窗）的宽度【vw、vh、vmin、vmax是css3新属性，支持主流浏览器且IE10以上】  .</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/04/axios/">
                <h3 class="media-heading">Axios</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Axios 问题提出 题目: axios是什么？怎么使用？描述使用它实现登录功能的流程
分析过程  axios是什么？  是基于promise的，用于浏览器和node.js的http客户端，主要作用是向后台发送请求的。
 优势   支持promise 提供一些并发的方法（最大优势） 提供拦截器（相当守卫） 浏览器支持防止CSRF（跨站请求伪造）   axios fetch ajax（jQuery）区别   相同点：都向后台请求数据 区别：前两者基于promise，后者主要还是利用callback的形式 fetch脱离了xhr是新的语法（默认不传cookie 另外不像xhr 可以监听到请求的进度）
  怎么使用？描述使用它实现登录功能的流程  npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/04/vue-router/">
                <h3 class="media-heading">Vue-router</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Vue-router 问题提出 题目: 导航钩子有哪些？他们有哪些参数？
分析过程  导航钩子翻译过来就是路由的生命周期（vue-router）
 其实分成两种 全局和局部
 全局的钩子函数 &gt; beforeEach(在路由切换开始时调用,路由守卫的实现) &gt; afterEach(在路由切换离开时调用)
 局部到单个路由 &gt; beforeEnter
 组件的钩子函数（局部到单个组件） &gt; beforeRouterEnter &gt; beforeRouterUpdate &gt; beforeRouterLeave
 使用的顺序 (组件的钩子函数&gt;局部到单个路由&gt;全局的钩子函数)
   const router = new VueRouter({ routes: routes, }) const routes = [ { path: '/', name: '/', component: Home, beforeEnter:function () { //局部到单个路由 } }, { path: '/login', name: 'login', component: Login }, { path: '/buy', name: 'buy', component: Buy, meta:{ auth:true } } ] //全局路由 /** to:即将进入目录对象 from:当前导航要离开的导航对象 next:是一个函数调用resolve 执行下一步 */ //实现路由守卫 router.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/04/vue%E5%9F%BA%E7%A1%80/">
                <h3 class="media-heading">Vue基础</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Vue基础 问题提出 题目: 说出4个vue当中的指令和它的用法
分析过程 1. v-if 条件渲染指令 代码存在销毁
2. v-bind 绑定指令 用来绑定属性 （简写:）
3. v-on 监听事件属性（简写@）
4. v-for 循环指令
5. v-model 数据双向绑定
 v-modle是什么   vue中利用它来进行表单数据的双向绑定（说白了，它只做了两个操作） v-bind绑定了一个value的属性 利用v-on把当前的元素绑定到一个事件上
  Vue中标签怎么绑定事件？  &lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;p&gt;{{message}}&lt;/p&gt; ------------------------&lt;br/&gt; &lt;input :value=&quot;message2&quot; @input=&quot;message2=$event.target.value&quot;&gt; &lt;p &gt;{{message2}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { message: &quot; &quot;, message2: &quot; &quot;, } }) &lt;/script&gt;  - 关于Vue
 vue是由饿了么ued团队开发并维护的一个渐进式js框架 vue是一个MVVM的框架</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/04/vuex/">
                <h3 class="media-heading">Vuex</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Vuex学习笔记 问题提出 题目: Vuex是什么？怎么使用？哪种功能场景是用它？
分析过程 1. Vuex是什么
Vuex是一个专门为Vue构建的状态集管理，主要是为了解决组件间状态共享的问题，强调的是集中式管理（说白了,主要是便于维护，便于解耦，所以不是所有的项目都适合使用vuex）如果不是大型项目使用vuex反而使项目代码繁琐多余
2. Vuex的核心
 state（不可缺，存储数据的位置） mutations （不可缺，用来变更状态） getters （类似vue中的computed，动态变更数据） actions （不可缺，动作层，与mutations一起使用，触发状态） modules （拆分state（仓库）方便取数据）  3. 状态集管理的流向
从视图流向actions，actions再commit给mutations，mutations再变更state状态，这三个合在一起就是Vuex，也就是store。
&lt;div id=&quot;app&quot;&gt; &lt;p&gt;更新技术{{count}}&lt;/p&gt; &lt;button @click=&quot;add&quot;&gt;++&lt;/button&gt; &lt;button @click=&quot;reduce&quot;&gt;--&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var store = new Vuex.Store({ state: { count: 0 }, mutations: { //唯一一个可以更改状态的地方 addState: function (state) { if (state.count &lt; 59) { state.count++; } else { state.count = 0; } }, reduceState: function (state) { if (state.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://zhengxiaomengmeng.github.io/2019/04/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E7%B1%BB/">
                <h3 class="media-heading">错误监控类</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">错误监控类 问题提出 题目: 错误监控类有哪些或者如何保证产品质量？？
分析过程 需要掌握得知识点
 前端错误的分类
 错误的捕获方式
 上报错误的基本原理
  1.前端错误的分类
 即时运行错误：代码错误
 资源加载错误：（js、css、图片加载失败）
  2.错误的捕获方式
 即时运行错误： try…catch(需要把try&hellip;catch布到代码中) window.onerror(dom0)只能捕获即时运行错误
  **资源加载错误：（js、css、图片加载失败）** object.onerror(通过节点绑onerror事件，捕获加载错误；) performance.getEntries(); 获取已加载资源时长，通过这个方式可以间接的拿到没有加载资源的错误； 返回的是一个数组，有forEach方法。 performance.getEntries().forEach(item=&gt;{console.log(item.name)});可以得到已成功加载的资源。 document.getElementsByTagName(‘img’);能拿到所有img的一个集合，是我们所需要加载的所有 图片的一个集合减去上面已成功加载的集合，剩下就是没有成功加载的。 Error事件捕获 window上通过事件捕获一样可以拦截到资源加载错误。可以在捕获阶段拿到这个。 body中: &lt;script src=“//baidu.com/test.js” charset=“utf-8”&gt;&lt;/script&gt;//不存在 为了证明捕获可以拿到这个事件； head中： &lt;script&gt; window.addEventListener(‘error’,function(e){ conosle.log(‘捕获’,e); }); &lt;/script&gt; ==&gt;报错 GETfiles | baidu.com | test.js 没找到 捕获 Event {isTrusted:true,’type’:’error’,target:script,currentTarget:window,eventphase:1…} 不会冒泡，script标签发生了错误，触发本身onerror事件已经可以了，不会向上冒泡到window。  延伸：跨域JS运行错误可以捕获吗，错误提示是什么，应该怎么处理？ 可以拿到所有跨域文件的代码错误；
Resource interpreted as script but transferred 错误信息：Script error.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         42 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://zhengxiaomengmeng.github.io/images/cover1.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://zhengxiaomengmeng.github.io/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/zhengxiaomengmeng.github.io\/2019\/04\/%E9%80%9A%E4%BF%A1%E7%B1%BB\/';
          
            this.page.identifier = '\/2019\/04\/%E9%80%9A%E4%BF%A1%E7%B1%BB\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'Dream\x27s blog';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

