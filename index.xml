<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome to Dream&#39;s blog </title>
    <link>https://zhengxiaomengmeng.github.io/</link>
    <description>Recent content on Welcome to Dream&#39;s blog </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Apr 2019 22:43:59 +0800</lastBuildDate>
    
	<atom:link href="https://zhengxiaomengmeng.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DOM事件类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/dom%E4%BA%8B%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Tue, 23 Apr 2019 22:43:59 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/dom%E4%BA%8B%E4%BB%B6%E7%B1%BB/</guid>
      <description></description>
    </item>
    
    <item>
      <title>税友实习生一二三面</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E7%A8%8E%E5%8F%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E4%BA%8C%E4%B8%89%E9%9D%A2/</link>
      <pubDate>Mon, 22 Apr 2019 21:53:35 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E7%A8%8E%E5%8F%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E4%BA%8C%E4%B8%89%E9%9D%A2/</guid>
      <description>人生第一次面试，记录一下！
从做完税友的笔试到现场面试中间只隔四天，笔试内容需要关注上届的笔试题，我这次做的笔试题和师兄秋招的题是一样的。笔试内容分成两块：选择题和问答题，题目都很简单，和大公司的笔试不在一个档次。 税友实习生面试总共有一二三面，一面是技术面，二面是HR面，三面是技术总监面，（有可能一面和二面顺序互换），面试的时候问的都是基础题，只要准备过，经历三轮面试基本没问题，下面列的是一二三面问到的问题。
一面（技术面）：简历上怎么写面试官就怎么问（40分钟左右） 1.自我介绍（注意：最好摆脱官方自我介绍，在自我介绍的时候可以加点简历上没有写的内容） 2.localStorage、sessionStorage、Cookie的区别、用法、优缺点（看时需要知道它们各自的存放数据大小） 3.html5有哪些新特性（讲自己用到过的，在哪里用到，实现什么功能） 4.ES6的新特性 5.什么是原型，什么是原型链 6.讲述一下使用JQuery和Vue框架的优缺点 7.兼容性问题，平时在项目中怎么处理 8.Vue的数据双向绑定原理 9.在使用Vue时，通过什么方式获取后端数据，并怎么实现（其实他想知道的是axios插件） 10.在IE浏览器处理兼容性时，hack用法 11.用原生的js写Ajax 12.echarts感觉如何，有没有应用过 13.平时如何学前端的技术，有没有了解新技术，关注哪些人博客或公众号，对前端所需要的技术栈了解没（入门学什么，中期学什么，后期学什么） 14.为什么选择前端这个职业，它对你的吸引在哪里 15.在项目中如何和后端开发人员合作 16.项目中遇到什么问题，怎么解决（平时遇到问题最好做下笔记） 17.for、foreach、map如何跳出循环
只记得问了上述的问题，其他问题忘了，问题问完后，每轮都会提问还有什么想问的吗（需要用心准备，都是有套路的） 最后给我一道题目，并且给我花两分钟时间，让我判断七个杯里哪个被子会有水
二面（HR面）（25分钟左右） 1.优缺点 2.你认为中大型企业招聘实习生的要求是什么 3.学习规划 4.调查户口 5.期待工资（不要太直接，最好给个范围） 6.前端吸引你的地方 7.在前端这职位的发展规划 8.对于上一轮面试印象最深刻的问题 9.聊本科（主要是我本科在东北，所有他们比较好奇） 10. &amp;hellip;..忘了
提问还有什么想问的
三面（技术总监面）（40分钟左右） 1.为什么选择前端这工作，对前端的理解 2.在考虑利益最大化，你比本科生的优势在哪里 3.怎么学习前端（这一块他给我讲了很多，给我规划了一下接下来的学习方向：要深入原理看） 4&amp;hellip;.忘了
给我的感觉吧，基础很重要，基础扎实一般都没问题，这公司没深入问项目，有点与众不同，最重要的是它更偏爱本科生。</description>
    </item>
    
    <item>
      <title>CSS盒子模型的联想</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%81%94%E6%83%B3/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%81%94%E6%83%B3/</guid>
      <description>CSS盒子模型的联想 问题提出 题目:谈谈你对CSS盒子模型的认识。
分析过程 需要掌握得知识点 基本概念：标准模型+ IE模型(区别) CSS如何设置这两种模型 JS如何设置获取盒子模型对应的宽和高 实例题(根据盒模型解释边距重叠) BFC(边距重叠解决方案)
1. 基本概念：标准模型+ IE模型(区别) 从上图可以看到标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。
从上图可以看到 IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。
2. CSS如何设置这两种模型 box-sizing:conent-box;（默认）标准的盒子模型 box-sizing:border-box;IE盒子模型
3. JS如何设置获取盒子模型对应的宽和高 dom.style.width/height（获取内联节点的宽高） dom.currentStyle.width/height (ie支持) window.getComputedStyle(dom).width/height;（都支持，兼容性更好） dom.getBoundingClientRect().width/height;（计算圆速的绝对定位，可以返回四个值：left，right，top，bottom，从而计算出宽高）。
4. 实例题(根据盒模型解释边距重叠) 问题：如上图有两个元素其中子元素高度为100px,子元素与父元素的上边距为 10px,求父元素的实际高度？
答案:说100px 对，说110px 也对，为什么捏？这个要看父元素的盒模型要怎么设置的，上代码演示咯，注意看噢：
&amp;lt;style&amp;gt; html,*{ padding: 0;margin: 0; } #sec{ background: #f00; } .child{ height: 100px; margin-top: 10px; background: yellow; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;section id=&amp;quot;sec&amp;quot;&amp;gt; &amp;lt;article class=&amp;quot;child&amp;quot;&amp;gt; &amp;lt;/article&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;/body&amp;gt;  上图证明 100px 是对的。</description>
    </item>
    
    <item>
      <title>三栏布局实现方案及其比较</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%8F%8A%E5%85%B6%E6%AF%94%E8%BE%83/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%8F%8A%E5%85%B6%E6%AF%94%E8%BE%83/</guid>
      <description>三栏布局实现方案及其比较 问题提出 假设高度已知，请写出三栏布局，左栏、右栏宽度300px，中间宽度自适应。
分析过程 这道题本身的难度并不大，我们在布局页面的时候，写个三栏布局还是挺简单的。但是如果在面试的时候遇到这道题，就没有那么简单了。看似简单的一道题，想把它答好是不简单的。往往越简单的题越不好答。如果看到这题只想到了float和absolute，那这题你连及格都及格不了。
实现过程 下面有5种三栏布局方式，先设置最初的样式。
&amp;lt;style&amp;gt; html, * { padding: 0; margin: 0; } .layout article div { min-height: 100px; } .layout{ margin-top: 20px; } &amp;lt;/style&amp;gt;  1.float布局
&amp;lt;section class=&amp;quot;layout float&amp;quot;&amp;gt; &amp;lt;style media=&amp;quot;screen&amp;quot;&amp;gt; .layout.float .left { float: left; width: 300px; background: #45ff96; } .layout.float .right { float: right; width: 300px; background: #bce8f1; } .layout.float .center { /*min-height: 100%;*/ background: #e7f1a6; } &amp;lt;/style&amp;gt; &amp;lt;article class=&amp;quot;left-right-center&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt; &amp;lt;h1&amp;gt;浮动解决方案&amp;lt;/h1&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>JavaScript堆栈原理</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/javascript%E5%A0%86%E6%A0%88%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 07 Mar 2019 22:31:13 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/javascript%E5%A0%86%E6%A0%88%E5%8E%9F%E7%90%86/</guid>
      <description>JavaScript堆栈原理 堆&amp;amp;栈 两者都是用来存放临时数据。
栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。
堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。
栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。
堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
栈（数据结构）：一种先进后出的数据结构。
数据类型访问&amp;amp;&amp;amp;复制 基本数据类型：基本数据类型值指保存在栈内存中的简单数据段。访问方式是按值访问。
 var a =1 ;
 栈内存  a 1        操作的是变量实际保存的值。当a = 2时，栈内存的1直接改成2。
 基本类型变量的复制：从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上。
 var b=a;
 栈内存  a 1  b 1    var b=2; //把栈中b所对应的值改成2，a的值不变，仍然是1；
 引用数据类型：引用数据类型值指保存在堆内存中的对象。也就是，变量中保存的实际上的只是一个指针，这个指针指向内存中的另一个位置，该位置保存着对象。访问方式是按引用访问。
 var a = new Object(); //(引用指针指向object)
 栈内存  堆内存  a 引用指针 object            当操作时，需要先从栈中读取内存地址，然后再延指针找到保存在堆内存中的值再操作。</description>
    </item>
    
    <item>
      <title>各种布局的优缺点</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/%E5%90%84%E7%A7%8D%E5%B8%83%E5%B1%80%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/%E5%90%84%E7%A7%8D%E5%B8%83%E5%B1%80%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</guid>
      <description>各种布局的优缺点 这篇博客讲的非常详细</description>
    </item>
    
    <item>
      <title>各种布局优缺点</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/%E5%90%84%E7%A7%8D%E5%B8%83%E5%B1%80%E4%BC%98%E7%BC%BA%E7%82%B9/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/%E5%90%84%E7%A7%8D%E5%B8%83%E5%B1%80%E4%BC%98%E7%BC%BA%E7%82%B9/</guid>
      <description> Grid(网格) 布局 CSS Grid(网格) 布局（又称为 “Grid(网格)” ），是一个二维的基于网格的布局系统，它的目标是完全改变我们基于网格的用户界面的布局方式。
Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局，而不是复杂的二维布局（实际上 Flexbox 和 Grid 能协同工作，而且配合得非常好）。
 静态布局 传统布局，屏幕宽高变化时，盒子使用横向或者竖向的滚动条来查看被遮挡部分，也就是不管浏览器窗口的大小怎么变化就按html语义标签排列的布局来布置。 弹性布局 css3引入的，flex布局；优点在于其容易上手，根据flex规则很容易达到某个布局效果，然而缺点是：浏览器兼容性比较差，只能兼容到ie9及以上； 自适应布局 分别为不同的屏幕分辨率定义布局，在每个布局中，页面元素不随窗口大小的调整而发生变化，当窗口大小到达一定分辨率时变化一次。 流式布局 页面元素的宽度按照屏幕进行适配调整，元素的位置不变，大小变化，屏幕太大或者太小导致元素不能正常显示。 响应式布局 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;divice-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&amp;quot;&amp;gt;
使用meta标签设置，页面元素宽度随窗口调整自动适配。主要属性及其含义如下：name=&amp;ldquo;viewport&amp;rdquo;： 名称=视图；width=device-width 页面宽度=设备宽度(可以理解为获取你手机的屏幕宽度)；initial-scale - 初始的缩放比例；minimum-scale - 允许用户缩放到的最小比例 ；maximum-scale - 允许用户缩放到的最大比例 ；user-scalable - 用户是否可以手动缩放 。
 网格布局：grid二维布局系统，随意的定义每行每列的数目和大小。也非常简单方便，兼容性较差。   </description>
    </item>
    
    <item>
      <title>meta viewport设置移动端自适应</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/meta-viewport%E8%AE%BE%E7%BD%AE%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/meta-viewport%E8%AE%BE%E7%BD%AE%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94/</guid>
      <description> meta viewport设置移动端自适应 viewport 移动设备上的viewport是设备屏幕上用来显示网页的那部分区域，再具体一点就是浏览器上用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。在默认情况下，移动设备上的viewport都是大于浏览器可视区域的，这是因为移动设备的分辨率相对于PC来说都比较小，所以为了能在移动设备上正常显示那些为PC浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，由设备本身决定），但后果是浏览器出现横向滚动条，因为浏览器可视区域的宽度比默认的viewport的宽度小。
3个viewport （1）layout viewport
如果把移动设备上浏览器的可视区域设为viewport的话，某些网站会因为viewport太窄而显示错乱，所以这些浏览器就默认会把viewport设为一个较宽的值，比如980px，使得即使是那些为PC浏览器设计的网站也能在移动设备浏览器上正常显示。这个浏览器默认的viewport叫做 layout viewport。layout viewport的宽度可以通过 document.documentElement.clientWidth来获取。
（2）visual viewport
layout viewport的宽度是大于浏览器可视区域的宽度的，所以还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做 visual viewport。visual viewport的宽度可以通过 document.documentElement.innerWidth来获取。
（3）ideal viewport
ideal viewport是一个能完美适配移动设备的viewport。首先，不需要缩放和横向滚动条就能正常查看网站的所有内容；其次，显示的文字、图片大小合适，如14px的文字不会因为在一个高密度像素的屏幕里显示得太小而无法看清，无论是在何种密度屏幕，何种分辨率下，显示出来的大小都差不多。这个viewport叫做 ideal viewport。
ideal viewport并没有一个固定的尺寸，不同的设备有不同的ideal viewport。例如，所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640。
ideal viewport 的意义在于，无论在何种分辨率的屏幕下，针对ideal viewport 而设计的网站，不需要缩放和横向滚动条都可以完美地呈现给用户。
利用meta标签对viewport进行控制 移动设备默认的viewport是layout viewport，，但在进行移动设备网站的开发时，需要的是ideal viewport。要得到ideal viewport，需要用到meta标签。
head标签中加入：
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&amp;quot;&amp;gt;  该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。当然maximum-scale=1.0, user-scalable=0不是必需的，是否允许用户手动播放根据网站的需求来定，但把width设为width-device基本是必须的，这样能保证不会出现横向滚动条。 width能控制layout viewport的宽度，如果不指定该属性，layout viewport将默认为980px或1024px（也可能是其它值，由设备本身决定），如果把layout viewport的宽度设置为移动设备的宽度，那么layout viewport将成为ideal viewport。
其实，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置width=device-width，也可以设置initial-scale=1，但有一个小缺陷，就是width=device-width会导致iphone、ipad横竖屏不分，initial-scale=1会导致IE横竖屏不分，都以竖屏的ideal viewport宽度为准。所以，最完美的写法两者都写上去， initial-scale=1 解决 iphone、ipad的缺陷，width=device-width解决IE的缺陷。
viewport设置移动端自适应的方法：
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;  </description>
    </item>
    
    <item>
      <title>浮动元素引起的问题和解决办法</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>浮动元素引起的问题和解决办法 问题  多个浮动的元素无法撑开父元素的宽度，父元素的高度可能会变成0。 若浮动元素后面跟非浮动元素，非浮动元素会紧随其后浮动起来。 若浮动元素前面还有同级元素没有浮动则会影响页面结构。  解决办法  clear:both 在最后一个浮动元素后面添加属性为clear:both;的元素。  &amp;lt;style&amp;gt; div.parent&amp;gt;div.fl{ float: left; width: 200px; height: 200px; margin-right: 20px; border: 1px solid red; } .clear{ clear: both; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;quot;parent&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;clear&amp;quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;  给父元素添加clear:both;属性的:after伪元素。
&amp;lt;style&amp;gt; div.parent&amp;gt;div.fl{ float: left; width: 200px; height: 200px; margin-right: 20px; border: 1px solid red; } .clear:after{ content: &#39;&#39;; display: block; clear: both; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;quot;parent clear&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;  注意：伪元素默认是内联水平，所以借助伪元素时要设置属性display: block;。</description>
    </item>
    
    <item>
      <title>css js文件放置位置和原因</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/css-js%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/css-js%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%8E%9F%E5%9B%A0/</guid>
      <description>css js文件放置位置和原因 js文件最好放在body中，也就是标签前，因为放在所有body中的标签后面就不会出现网页加载时出现空白的情况，可以持续的给用户提供视觉反馈，同时在有些情况下，会降低错误的发生。
而css标签应该放在标签之间，因为如果放在标签的前面，那么当DOM树构建完成了，渲染树才构建，那么当渲染树构建完成，浏览器不得不再重新渲染整个页面，这样造成了资源的浪费。效率也不高。如果放在之间，浏览器边构建边渲染，效率要高的多。</description>
    </item>
    
    <item>
      <title>IE中常见BUG（兼容性问题）</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/ie%E4%B8%AD%E5%B8%B8%E8%A7%81bug%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/ie%E4%B8%AD%E5%B8%B8%E8%A7%81bug%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</guid>
      <description>https://www.cnblogs.com/songzk/p/6181641.html</description>
    </item>
    
    <item>
      <title>css实现水平、垂直居中</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</guid>
      <description>css实现水平、垂直居中 元素水平居中 块级元素水平居中 最简单的方式：margin： 0 auto; 注意点 (1)元素需要设置宽度 (2)元素不能为行内元素
行内元素水平居中 元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。（对于块级元素不起作用）
不定宽度的块状元素有三种方法居中（这三种方法目前使用的都比较多）： 1.加入 table 标签 第一步：为需要设置的居中的元素外面加入一个 table 标签 ( 包括 、、 ) 第二步：为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样）
&amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;不定宽块状元素水平居中&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; table{ margin:0 auto; } ul{list-style:none;margin:0;padding:0;} li{float:left;display:inline;margin-right:8px;} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt; &amp;lt;table&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  2.设置 display;inline 方法 改变块级元素的 dispaly 为 inline 类型，然后使用 text-align:center 来实现居中效果。</description>
    </item>
    
    <item>
      <title>css实现隐藏页面的方式</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/css%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/css%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>css实现隐藏页面的方式 opacity 设置透明度，值为0-1。为0则页面上不显示，但是元素还在那个位置,依然可以网页交互,单纯是看不到而已。在呈现上与visibility:hidden;方式一样，同样会占据页面空间。
.class{ opacity:0; }  visibility 设置隐藏。hidden为隐藏，在页面不显示，交互效果也会没有。visible为显示,hidden为隐藏。该方法仍占用页面空间，但是不会导致浏览器重排，但是会重绘。
.class{ visibility:hidden;//隐藏 visibility:visible;//显示 }  display 设置不显示和显示。注意了，这里要强调的一点是，如果你想使他的子元素显示，用display:visible是没用的。而上面两种方式是可以使用。该方法不占用空间，会导致浏览器的重排和重绘。
.class { display:none; }  position position位置，用绝对定位把它挪到远远地。
.class{ position:absolute; left:-999px; top:-999px; }  Clip-path 该属性很少见，该属性是通过裁剪的方法实现隐藏的。被隐藏的内容依然占据着那个位置，它周围的元素的行为就如同它可见时一样。记住用户交互例如鼠标悬停或者点击在剪裁区域之外也不可能生效。此外，这个属性能够使用各种过渡动画来实现不同的效果。
.haorooms-small { background-size: cover; width: 300px; height: 300px; -webkit-clip-path: polygon(0% 50%, 25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%); clip-path: polygon(0% 50%, 25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%); }  &amp;lt;div class=&amp;quot;haorooms-small&amp;quot; style=&amp;quot;background-image: url(&#39;http://sandbox.</description>
    </item>
    
    <item>
      <title>display、position的属性和作用</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/displayposition%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/displayposition%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%9C%E7%94%A8/</guid>
      <description>display、position的属性和作用 display 的值的作用： 1.block 像块类型元素一样显示。 2.inline 像行内元素类型一样显示。 3.inline-block 像行内元素一样显示，但其内容像块类型元素一样显示。 4.list-item 像块类型元素一样显示，并添加样式列表标记。
position 的值的定位区别： 1.absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。 2.fixed 生成绝对定位的元素，相对于浏览器窗口进行定位（老IE不支持）。 3.relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 4.static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 5.inherit 规定从父元素继承 position 属性的值。</description>
    </item>
    
    <item>
      <title>meta标签</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/meta%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/meta%E6%A0%87%E7%AD%BE/</guid>
      <description>meta标签使用总结</description>
    </item>
    
    <item>
      <title>盒子模型 box-sizing</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B-box-sizing/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B-box-sizing/</guid>
      <description>盒子模型 box-sizing 盒子模型 盒子模型由元素内容(content)、元素的内边距(padding:内容与边框之间的距离)，元素的边框(border)，元素的外边距(margin:边框与外部元素之间的距离)四个部分，这四个部分一起构成了盒子模型。
对于padding、margin的取值 （注意：不允许取负值）
注意：margin重叠，也叫 margin塌陷
标准文档流中，两个盒子，分别有上下外边距，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的)。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;margin叠加&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; *{ padding: 0; margin: 0; } .a{ width: 100px; height: 100px; border:1px solid; background-color: teal; margin-bottom: 10px; } .b{ width: 100px; height: 100px; border:1px solid; background-color: red; margin-top: 20px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;quot;a&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;b&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  注意：上下两个盒子的距离不是30px；而是20px，上面两个盒子的margin值不叠加，只取较大的值作为margin。
另外：margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。
如果向设置父子之间的距离，我们最好使用父元素的padding。
box-sizing box-sizing 属性允许以特定的方式定义匹配某个区域的特定元素,简单来说就是可以通过box-sizing的取值来切换盒模型，它的取值可以为content-box、border-box.默认属性是content-box。
W3C标准盒子（content-box）：又称内容盒子，是指块元素box-sizing属性为content-box的盒模型。一般在现代浏览器中使用的都是正常盒模型content-box。它所说的width一般只包含内容，不包含padding与margin，并且盒子的大小会以内容优先，自动扩展，子元素可以撑开父元素.可以理解为现实生活中的气球，大小可以随内容的变化而变化。
 在这种盒模型下，我们所说的元素的 width ，实际上只包含 content。盒子总宽度 = margin + border + padding + width</description>
    </item>
    
    <item>
      <title>使用data-的好处</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E4%BD%BF%E7%94%A8data-%E7%9A%84%E5%A5%BD%E5%A4%84/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E4%BD%BF%E7%94%A8data-%E7%9A%84%E5%A5%BD%E5%A4%84/</guid>
      <description>使用data-的好处  data-* 属性用于存储页面或应用程序的私有自定义数据。
 data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。
  存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。
 data-* 属性包括两部分：  (1) 语法 1. 属性名不应该包含任何大写字母，并且在前缀 &amp;ldquo;data-&amp;rdquo; 之后必须有至少一个字符 2. 属性值可以是任意字符串
注释：用户代理会完全忽略前缀为 &amp;quot;data-&amp;quot; 的自定义属性。  好处
通过data-可以自定义属性,可以通过HTMLElement.dataset获取这些属性的值,data-中-后接自定义属性的名字,例如data-url。实际开发中可以利用这一点在生成DOM结构时把数据储存在自定义属性中,通过一系列交互操作,可以再获得这些数据,而不用再去ajax去后台取得数据。</description>
    </item>
    
    <item>
      <title>CSS动画</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/css%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Tue, 26 Feb 2019 15:41:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/css%E5%8A%A8%E7%94%BB/</guid>
      <description>CSS动画 CSS动画主要是有transition属性完成的，animation属性是解决transition属性中遇到的一些问题。动画的实质就是某些css样式随时间的变化可以慢慢改变，不再是以前那种即时完成的，跟时间没关系。现在跟时间有关系，让仍感觉到是一幅动画。
transition transition： [ none | &amp;lt;single-transition-property&amp;gt; ] || &amp;lt;time&amp;gt; || &amp;lt;single-transition-timing-function&amp;gt; || &amp;lt;time&amp;gt;    transition-property ：检索或设置对象中的参与过渡的属性 transition-duration：检索或设置对象过渡的持续时间 transition-timing-function ：检索或设置对象中过渡的动画类型 transition-delay ：检索或设置对象延迟过渡的时间   &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; .test{ width: 100px; height: 100px; border:1px solid; transition: width 1s cubic-bezier(.11,.88,.25,-0.91), background 1s 1s ease-out } .test:hover{ width: 400px; background: red; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  使用注意点 （1）目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀。</description>
    </item>
    
    <item>
      <title>HTML与XHTML区别</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/html%E4%B8%8Exhtml%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/html%E4%B8%8Exhtml%E5%8C%BA%E5%88%AB/</guid>
      <description>HTML与XHTML区别 HTML(文本标记语言)是英文HyperText Markup Language的简称，用于创建网页的标准标记语言，html并不是编程语言，HTML 运行在浏览器上由浏览器来解析翻译给网站访客，它是建设网站的基础。
XHTML(可扩展标识语言)是The Extensible Markup Language的简写,XHTML1.0是源自W3C的最新的HTML标准，是Web的语言。
功能区别：
HTML对于各大浏览器兼容性较差(pc端浏览器、手机端浏览器、PAD)，对于网页页面编写技巧要求比较高，现在web前端开发的静态网页，一般都是html4.0，HTML5就另当别论了。
XHTML可以很好处理各大浏览器的兼容(pc端浏览器、手机端浏览器、PAD),XHTML的语法较为严谨，XHTML结合了部分XML的强大功能及大多数HTML的简单特性。
书写习惯区别
 HTML标签不区分大小写XHTML所有标签都必须小写。 XHTML标签必须成双成对。 html对标签顺序要求不严格，XHTML标签顺序必须正确。 XHTML 文档必须拥有根元素  总而言之xhtml比html更加规范</description>
    </item>
    
    <item>
      <title>渐进式渲染</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%B8%B2%E6%9F%93/</guid>
      <description>渐进式渲染 渐进式渲染（详情）就是一开始先加载首屏显示的内容，之后再随着时间或者滚动页面才进行后面的加载。</description>
    </item>
    
    <item>
      <title>浏览器的标准模式和怪异模式</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 25 Feb 2019 14:18:32 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F/</guid>
      <description> 浏览器的标准模式和怪异模式 现代的浏览器一般都有两种渲染模式：标准模式和怪异模式。
在标准模式下，浏览器按照HTML与CSS标准对文档进行解析和渲染；
而在怪异模式下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。
其实归根结底就是，浏览器如何能将旧网页与新网页区分开来。
标准模式与怪异模式的区别:
  #### 盒模型    图片元素的垂直对齐方式： 对于inline元素和table-cell元素，标准模式下vertical-align属性默认取值为baseline，在怪异模式下，table单元格中的图片的vertical-align属性默认取值为bottom，因此在图片底部会有及像素的空间。
 table 元素中的字体 CSS中，对于font的属性都是可以继承的，怪异模式下，对于table元素，字体的某些元素将不会从body等其他封装元素中继承得到，特别是font-size属性。
 内联元素的尺寸： 标准模式下，non-replaced inline 元素无法自定义大小
怪异模式下，定义这些元素的width，height属性可以影响这些元素显示的尺寸。
 元素的百分比高度： a：CSS中对于元素的百分比高度规定如下：百分比为元素包含块的高度，不可为负值，如果包含块的高度没有显示给出，该值等同于auto，所以百分比的高度必须在父元素有高度声明的情况下使用。
  b：当一个元素使用百分比高度时，标准模式下，高度取决于内容变化，怪异模式下，百分比高度被正确应用。
 #### 元素溢出的处理： 标准模式下，overflow取默认值visible，在怪异模式下，该溢出会被当做扩展box来对待，即元素的大小由其内容决定，溢出不会裁减，元素框自动调整，包含溢出内容。  </description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Sun, 24 Feb 2019 21:36:22 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E9%97%AD%E5%8C%85/</guid>
      <description>闭包 阮一峰学习闭包
闭包的概念 高程上关于闭包的定义：闭包是指有权访问另一个函数作用域中的变量的函数
简单理解就是：定义在一个函数内部的函数
在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
创建闭包的方式：在一个函数内部创建另一个函数
function f1(){ var n=999; function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999  其中f2( )就是一个闭包能够访问它上一级函数f1()中的变量n。
闭包关于作用域链的图示：
闭包的用途 1、读取其他函数内部的变量
2、让这些变量的始终保持在内存中，这是一个双刃剑，可以方便的访问内部的变量，即使函数执行完成，其内部变量还保存在内存中可以访问，但是也会带来一系列的问题，外部函数的作用域链和变量对象不能销毁，占用内存。
来看一个典型的例子
var result = new Array(); function createFunctions(){ for (var i=0; i &amp;lt; 10; i++){ result[i] = function(){ console.log(i); }; } } result[6](); //10  从表面上看，似乎每一个函数都返回10 ，但实际上，每个函数都返回10， 因为每个函数的作用域链中都保存着父级函数的活动对象，他们的引用的都是同一个变量i，当父级函数return result 后，变量i的值变成10 ，每个函数引用保存变量i的同一个变量对象，因为此时i=10，所以引用变量指向的值都变成10。
解决这个问题最方便的一个方法是将闭包函数立即执行，每次引用都变成实际i对应的值。每次循环立即执行后销毁引用变量。
var result = new Array(); function createFunctions(){ for (var i=0; i &amp;lt; 10; i++){ result[i] = function(){ var c = i; return function () { console.</description>
    </item>
    
    <item>
      <title>flex布局</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/flex%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sat, 23 Feb 2019 15:41:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/flex%E5%B8%83%E5%B1%80/</guid>
      <description>关于CSS3的flex布局，阮一峰的两篇讲解十分到位！
阮一峰 &amp;amp; Flex 布局教程：语法篇
阮一峰 &amp;amp; Flex 布局教程：实例篇
一、Flex布局是什么？ Flex是Flexible Box的缩写，意为&amp;rdquo;弹性布局&amp;rdquo;，用来为盒状模型提供最大的灵活性！
任何一个容器都可以指定为Flex布局。
.box{ display: flex; }  行内元素也可以使用Flex布局。
.box{ display: inline-flex; }  Webkit 内核的浏览器，必须加上-webkit前缀。
.box{ display: -webkit-flex; /* Safari */ display: flex; }  基本概念 采用Flex布局的元素，称为Flex容器（flex container），简称&amp;rdquo;容器&amp;rdquo;。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&amp;rdquo;项目&amp;rdquo;。
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。
基本语法 容器的六个基本属性：  flex-direction  决定主轴的方向
flex-direction: row(默认值,主轴为水平方向，起点在左端) | row-reverse(主轴为水平方向，起点在右端) | column(主轴为垂直方向，起点在上沿) | column-reverse(主轴为垂直方向，起点在下沿);
 flex-wrap  定义，如果一条轴线排不下，如何换行。
flex-wrap: nowrap(默认，不换行) | wrap(换行，第一行在上方) | wrap-reverse（换行，第一行在下方）;  flex-flow flex-direction属性和flex-wrap属性的简写形式</description>
    </item>
    
    <item>
      <title>Position</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/position/</link>
      <pubDate>Fri, 22 Feb 2019 15:41:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/position/</guid>
      <description>position定位 position属性值 参考http://www.cnblogs.com/theWayToAce/p/5264436.html
static （静态定位）：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）
relative （相对定位）：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。　absolute （绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &amp;ldquo;left&amp;rdquo;, &amp;ldquo;top&amp;rdquo;, &amp;ldquo;right&amp;rdquo; 以及 &amp;ldquo;bottom&amp;rdquo; 属性进行规定。可通过z-index进行层次分级。
fixed （固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 &amp;ldquo;left&amp;rdquo;, &amp;ldquo;top&amp;rdquo;, &amp;ldquo;right&amp;rdquo; 以及 &amp;ldquo;bottom&amp;rdquo; 属性进行规定。可通过z-index进行层次分级。
fixed很适合用于固定某个div或者侧边栏在页面中不随页面滚动而滚动。
关于absolute与relative之间的区别，详细可以参考原文</description>
    </item>
    
  </channel>
</rss>