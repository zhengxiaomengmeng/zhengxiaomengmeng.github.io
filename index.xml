<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome to Dream&#39;s blog </title>
    <link>https://zhengxiaomengmeng.github.io/</link>
    <description>Recent content on Welcome to Dream&#39;s blog </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 Mar 2019 22:31:13 +0800</lastBuildDate>
    
	<atom:link href="https://zhengxiaomengmeng.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JavaScript堆栈原理</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/javascript%E5%A0%86%E6%A0%88%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 07 Mar 2019 22:31:13 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/javascript%E5%A0%86%E6%A0%88%E5%8E%9F%E7%90%86/</guid>
      <description>JavaScript堆栈原理 堆&amp;amp;栈 两者都是用来存放临时数据。
栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。
堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。
栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。
堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
栈（数据结构）：一种先进后出的数据结构。
数据类型访问&amp;amp;&amp;amp;复制 基本数据类型：基本数据类型值指保存在栈内存中的简单数据段。访问方式是按值访问。
 var a =1 ;  栈内存  a 1      
操作的是变量实际保存的值。当a = 2时，栈内存的1直接改成2。
 基本类型变量的复制：从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上。 &amp;gt; var b=a;  栈内存  a 1  b 1  
 var b=2; //把栈中b所对应的值改成2，a的值不变，仍然是1；
 引用数据类型：引用数据类型值指保存在堆内存中的对象。也就是，变量中保存的实际上的只是一个指针，这个指针指向内存中的另一个位置，该位置保存着对象。访问方式是按引用访问。
 var a = new Object(); //(引用指针指向object)
 栈内存  堆内存  a 引用指针 object            当操作时，需要先从栈中读取内存地址，然后再延指针找到保存在堆内存中的值再操作。 a.</description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Sun, 24 Feb 2019 21:36:22 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E9%97%AD%E5%8C%85/</guid>
      <description>闭包 阮一峰学习闭包
闭包的概念 高程上关于闭包的定义：闭包是指有权访问另一个函数作用域中的变量的函数
简单理解就是：定义在一个函数内部的函数
在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
创建闭包的方式：在一个函数内部创建另一个函数
function f1(){ var n=999; function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999  其中f2( )就是一个闭包能够访问它上一级函数f1()中的变量n。
闭包关于作用域链的图示：
闭包的用途 1、读取其他函数内部的变量
2、让这些变量的始终保持在内存中，这是一个双刃剑，可以方便的访问内部的变量，即使函数执行完成，其内部变量还保存在内存中可以访问，但是也会带来一系列的问题，外部函数的作用域链和变量对象不能销毁，占用内存。
来看一个典型的例子
var result = new Array(); function createFunctions(){ for (var i=0; i &amp;lt; 10; i++){ result[i] = function(){ console.log(i); }; } } result[6](); //10  从表面上看，似乎每一个函数都返回10 ，但实际上，每个函数都返回10， 因为每个函数的作用域链中都保存着父级函数的活动对象，他们的引用的都是同一个变量i，当父级函数return result 后，变量i的值变成10 ，每个函数引用保存变量i的同一个变量对象，因为此时i=10，所以引用变量指向的值都变成10。
解决这个问题最方便的一个方法是将闭包函数立即执行，每次引用都变成实际i对应的值。每次循环立即执行后销毁引用变量。
var result = new Array(); function createFunctions(){ for (var i=0; i &amp;lt; 10; i++){ result[i] = function(){ var c = i; return function () { console.</description>
    </item>
    
    <item>
      <title>flex布局</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/flex%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sat, 23 Feb 2019 15:41:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/flex%E5%B8%83%E5%B1%80/</guid>
      <description>关于CSS3的flex布局，阮一峰的两篇讲解十分到位！
阮一峰 &amp;amp; Flex 布局教程：语法篇
阮一峰 &amp;amp; Flex 布局教程：实例篇
一、Flex布局是什么？ Flex是Flexible Box的缩写，意为&amp;rdquo;弹性布局&amp;rdquo;，用来为盒状模型提供最大的灵活性！
任何一个容器都可以指定为Flex布局。
.box{ display: flex; }  行内元素也可以使用Flex布局。
.box{ display: inline-flex; }  基本概念 采用Flex布局的元素，称为Flex容器（flex container），简称&amp;rdquo;容器&amp;rdquo;。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&amp;rdquo;项目&amp;rdquo;。
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。
基本语法 容器的六个基本属性：  flex-direction  决定主轴的方向
flex-direction: row | row-reverse | column | column-reverse;
 flex-wrap  定义，如果一条轴线排不下，如何换行。
flex-wrap: nowrap | wrap | wrap-reverse;  flex-flow flex-direction属性和flex-wrap属性的简写形式
flex-flow:  || ;</description>
    </item>
    
    <item>
      <title>Position</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/position/</link>
      <pubDate>Fri, 22 Feb 2019 15:41:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/position/</guid>
      <description>position定位 position属性值 参考http://www.cnblogs.com/theWayToAce/p/5264436.html
static （静态定位）：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）
relative （相对定位）：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。　absolute （绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &amp;ldquo;left&amp;rdquo;, &amp;ldquo;top&amp;rdquo;, &amp;ldquo;right&amp;rdquo; 以及 &amp;ldquo;bottom&amp;rdquo; 属性进行规定。可通过z-index进行层次分级。
fixed （固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 &amp;ldquo;left&amp;rdquo;, &amp;ldquo;top&amp;rdquo;, &amp;ldquo;right&amp;rdquo; 以及 &amp;ldquo;bottom&amp;rdquo; 属性进行规定。可通过z-index进行层次分级。
fixed很适合用于固定某个div或者侧边栏在页面中不随页面滚动而滚动。
关于absolute与relative之间的区别，详细可以参考原文</description>
    </item>
    
  </channel>
</rss>