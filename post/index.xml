<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Welcome to Dream&#39;s blog </title>
    <link>https://zhengxiaomengmeng.github.io/post/</link>
    <description>Recent content in Posts on Welcome to Dream&#39;s blog </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Jun 2019 19:50:08 +0800</lastBuildDate>
    
	<atom:link href="https://zhengxiaomengmeng.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>用javascript实现用户登录验证的代码</title>
      <link>https://zhengxiaomengmeng.github.io/2019/06/%E7%94%A8javascript%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 03 Jun 2019 19:50:08 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/06/%E7%94%A8javascript%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <description>用javascript实现用户登录验证的代码 不带验证码 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0&amp;quot;/&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form id=&amp;quot;form1&amp;quot; action=&amp;quot;&amp;quot; method=&amp;quot;get&amp;quot;&amp;gt; &amp;lt;input name=&amp;quot;text1&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;&amp;quot; placeholder=&amp;quot;name&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;pwd&amp;quot; placeholder=&amp;quot;密码&amp;quot;&amp;gt; &amp;lt;input name=&amp;quot;text3&amp;quot; value=&amp;quot;submit&amp;quot; type=&amp;quot;submit&amp;quot; onclick=&amp;quot;subimtonclick()&amp;quot;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;script language=&amp;quot;JavaScript&amp;quot;&amp;gt; function subimtonclick() { var form1 = document.getElementById(&#39;form1&#39;); if (form1.text1.value == &amp;quot;&amp;quot;) { alert(&amp;quot;用户名不能为空&amp;quot;); form1.text1.focus(); return; } if (form1.text1.value.length &amp;lt; 6 || form1.text1.value.length &amp;gt; 10) { alert(&amp;quot;用户名不能少于六个字符，不能超过十个字符&amp;quot;); form1.text1.focus(); return; } if (form1.pwd.value == &amp;quot;&amp;quot;) { alert(&amp;quot;密码不能为空&amp;quot;); form1.</description>
    </item>
    
    <item>
      <title>重建二叉树</title>
      <link>https://zhengxiaomengmeng.github.io/2019/06/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 03 Jun 2019 15:33:47 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/06/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>重建二叉树 题目描述  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
 解题思路  由前序遍历可以得出二叉树的根节点是该序列的第一项，再在中序遍历中找到该节点所在的位子，因为中序遍历序列的根节点将数分布在左右两侧，将中序遍历序列左右的数分离出来，组成新序列，去掉前序遍历的第一个数，按照中序遍历左边数的个数分割前序遍历左右两边的数，再进行递归，返回二叉树&amp;hellip;
 代码实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function reConstructBinaryTree(pre, vin) { // write code here var result = null; if(pre.length&amp;gt;1){ var root = pre[0]; var rootIndex = vin.indexOf(pre[0]); var rootLeft = vin.slice(0,rootIndex); var rootRight = vin.slice(rootIndex+1,vin.length); pre.shift(); var preLeft = pre.slice(0,rootLeft.length); var preRight = pre.slice(rootLeft.length,pre.length); result={ val:root, left:reConstructBinaryTree(preLeft, rootLeft), right:reConstructBinaryTree(preRight, rootRight), } }else if (pre.</description>
    </item>
    
    <item>
      <title>用两个栈实现队列</title>
      <link>https://zhengxiaomengmeng.github.io/2019/06/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 02 Jun 2019 19:06:11 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/06/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description> 用两个栈实现队列 题目描述  用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
 分析思路  栈是先进后出，队列是先进先出的，想实现这功能则需要：设定两个数组，数组1是给push函数用的，数组2必须为空，如果数组1不为空的话，便将数组1的元素每pop出来直接push到数组2中，最后返回数组2 pop出来的元素，与push（）相结合，达到先进先出的效果。
 代码实现 var arr1 = []; var arr2 = []; function push(node) { // write code here arr1.push(node); } function pop() { // write code here if(arr1.length===0&amp;amp;&amp;amp;arr2.length===0){ return false }else if(arr2.length===0){ while(arr1.length!==0){ arr2.push(arr1.pop()) } } return arr2.pop() }  </description>
    </item>
    
    <item>
      <title>创建优先级队列类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/06/%E5%88%9B%E5%BB%BA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%B1%BB/</link>
      <pubDate>Sun, 02 Jun 2019 12:56:58 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/06/%E5%88%9B%E5%BB%BA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%B1%BB/</guid>
      <description> 创建优先级队列类 </description>
    </item>
    
    <item>
      <title>创建队列类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/06/%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97%E7%B1%BB/</link>
      <pubDate>Sat, 01 Jun 2019 12:49:16 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/06/%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97%E7%B1%BB/</guid>
      <description>创建队列类 概念  像堆栈一样，队列是元素的集合。但是与堆栈不同的是，队列遵循FIFO（先进先出）原则。添加到队列的元素被推送到队列的尾部或末尾，并且仅允许删除队列前面的元素。 我们可以使用一个数组来表示一个队列，但是像堆栈一样，我们要限制我们在队列中的控制量。 队列类的两个主要方法是: enqueue(data): 添加数据插入队尾 dequeue()： 读取队列头节点数据并删除该节点 其他有用的方法是: size(): 队列长度 empty()：判断队列是否为空 front()：查看队首元素 back()：查看队尾元素
 说明  编写一个将元素推送到队列尾部的 enqueue 方法，一个删除并返回前面元素的 dequeue 方法，一种让我们看到前面元素的 front 方法，一个显示长度的 size 方法，以及一个 isEmpty 方法来检查队列是否为空。
 实现要求 1. 你的 Queue 类应该有一个 enqueue 的方法。 2. 你的 Queue 类应该有一个 dequeue 的方法。 3. 你的 Queue 类应该有一个 front 的方法。 4. 你的 Queue 类应该有一个 size 的方法。 5. 你的 Queue 类应该有一个 isEmpty 的方法。 6. dequeue 方法应该删除并返回队列的前端元素 7. front 方法应该返回队列的前端元素的值 8. size 方法应该返回队列的长度 9.</description>
    </item>
    
    <item>
      <title>创建堆栈类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/06/%E5%88%9B%E5%BB%BA%E5%A0%86%E6%A0%88%E7%B1%BB/</link>
      <pubDate>Sat, 01 Jun 2019 12:29:46 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/06/%E5%88%9B%E5%BB%BA%E5%A0%86%E6%A0%88%E7%B1%BB/</guid>
      <description>创建堆栈类 题目  编写一个将元素推送到堆栈顶部的push方法，一种删除堆栈顶部元素的pop方法，一个查看堆栈中第一个元素的peek方法，一个检查堆栈是否为空的。 isEmpty方法，以及一个从堆栈中删除所有元素的clear方法。 通常堆栈没有这个，但是我们添加了一个print帮助器方法，控制台记录集合。
 实现要求 1. 你的 Stack 类应该有一个 push 方法。 2. 你的 Stack 类应该有一个 pop 方法。 3. 你的 Stack 类应该有一个 peek 方法。 4. 你的 Stack 类应该有一个 isEmpty 方法。 5. 你的 Stack 类应该有一个 clear 方法。 6. peek 方法应该返回堆栈的顶部元素 7. pop 方法应该删除并返回堆栈的顶部元素 8. 如果堆栈不包含任何元素，则 isEmpty 方法应返回true 9. clear 方法应该从堆栈中删除所有元素  代码实现 function Stack() { collection = []; this.print = function() { console.log(collection); }; // Only change code below this line this.</description>
    </item>
    
    <item>
      <title>通用的事件侦听函数</title>
      <link>https://zhengxiaomengmeng.github.io/2019/05/%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 27 May 2019 14:36:04 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/05/%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%87%BD%E6%95%B0/</guid>
      <description>通用的事件侦听函数 分析过程 需要考虑的问题如下几点：
 页面是否加载完成
 增加移除事件：DOM等级和不同浏览器之间的兼容性
 取消默认行为、阻止默认行为
 获取事件目标
  代码实现 //写一个通用的事件监听函数 markyun.Event = { //页面加载完成后 readyEvent: function (fn) { if (fn == null) { fn = document; } var oldonload = window.onload; if (typeof window.onload != &#39;function&#39;) { window.onload = fn; } else { window.onload = function () { oldonload(); fn(); } } }, //分别使用dom0，dom2或IE方式来绑定事件 //参数：操作的元素、事件名称、事件处理程序 addEvent: function (element, type, handler) { if (element.addEventListener) { element.</description>
    </item>
    
    <item>
      <title>Mock数据</title>
      <link>https://zhengxiaomengmeng.github.io/2019/05/mock%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Fri, 24 May 2019 15:12:04 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/05/mock%E6%95%B0%E6%8D%AE/</guid>
      <description>Vue-cli 本地开发mock数据使用方法 参考博客： vue-cli 本地开发mock数据使用方法</description>
    </item>
    
    <item>
      <title>使用indexOf判断一个字符串包含另一个字符串</title>
      <link>https://zhengxiaomengmeng.github.io/2019/05/%E4%BD%BF%E7%94%A8indexof%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 22 May 2019 17:51:22 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/05/%E4%BD%BF%E7%94%A8indexof%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description> 使用indexOf判断一个字符串包含另一个字符串 题目  请实现 javascript 中的 indexOf 功能，判断一个字符串 a 中是否包含另一个字符串 b。 a）如果包含，需要返回匹配字符串 b 的位置。 b）如果不包含，需要返回-1。 如：indexOf(&amp;ldquo;hello&amp;rdquo;,&amp;ldquo;el&amp;rdquo;) return 1。
 代码实现 function indexOf1(a,b) { var result = a.match(b); return result?result.index:-1; } function indexOf2(a,b) { return a.search(b); } console.log(indexOf2(&#39;axcvvb&#39;,&#39;cv&#39;))  </description>
    </item>
    
    <item>
      <title>ProxyTable 解决开发环境的跨域问题</title>
      <link>https://zhengxiaomengmeng.github.io/2019/05/proxytable-%E8%A7%A3%E5%86%B3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 22 May 2019 11:17:33 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/05/proxytable-%E8%A7%A3%E5%86%B3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</guid>
      <description>Vue-cli中的proxyTable解决开发环境的跨域问题  对于前端开发人员来讲，当你在开发环境中与后台开发人员进行数据联调时，总会遇到烦人的跨域问题！
 解决跨域的方法有很多种，比如你和后台人员经过友好协商后，你可以通过JSONP的方式或者让后台人员将代码设置为允许你进行跨域！但是往往前后台开发人员的配合默契度是不太高的。如果后台只给你接口，并明确告诉你不允许修改接口，怎么办？怎么办才能实现跨域？此时你就可以通过proxyTable来解决跨域问题！
 通过proxyTable解决跨域在Vue-cli当中是很简单的。只需修改config文件夹下的index.js中的proxyTable就能实现：
 //代理配置表，在这里可以配置特定的请求代理到对应的API接口 proxyTable:{ &amp;quot;/api&amp;quot;:{ target:&amp;quot;http://www.xxx.com&amp;quot;, //访问的服务器地址 changeOrigin:true, //true为开启代理 //secure: true, // 如果是https接口，需要配置这个参数 pathRewrite:{ &#39;^/api&#39;: &#39;/&#39; //路径的替换规则 /* *这里的配置是正则表达式，以/api开头的路径将会被‘/&#39;替换掉 *假如后台文档的接口是 &amp;quot;http://www.xxx.com/user/add&amp;quot; *前端调取API接口应写：axios.get(&#39;/api/user/add&#39;) */ } } }   以上代码的“/api”你可以认为用于代替target里面的地址，调取接口的地址直接用api来替换。
比如后台接口地址为：”http://www.xxx.com/user/login“。 你可以直接写为：”/api/user/login”即可。
 可以根据不同的API域名负责的模块不同来进行多项配置
//代理配置表，在这里可以配置特定的请求代理到对应的API接口 proxyTable:{ &amp;quot;/adv&amp;quot;:{ target:&amp;quot;http://adv.com&amp;quot;,//访问的服务器地址 changeOrigin:true,//true为开启代理 pathRewrite:{ &#39;^/adv&#39;: &#39;/&#39;//路径的替换规则 } }， &amp;quot;/user&amp;quot;:{ target:&amp;quot;http://user.com&amp;quot;,//访问的服务器地址 changeOrigin:true,//true为开启代理 pathRewrite:{ &#39;^/user&#39;: &#39;/&#39;//路径的替换规则 } } }   以上代码”/adv”与”/user”分别负责项目中的广告模块与用户模块。 例如： 后台文档的地址是：“http://adv.com/add”， 前端调取API接口应写：axios.get(‘/adv/add’)
 注意： 配置修改完以后一定要重新npm run dev 一次</description>
    </item>
    
    <item>
      <title>Set和Map</title>
      <link>https://zhengxiaomengmeng.github.io/2019/05/set%E5%92%8Cmap/</link>
      <pubDate>Mon, 13 May 2019 12:56:29 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/05/set%E5%92%8Cmap/</guid>
      <description>Set ES6提供了新的数据结构Set。类似于数组，只不过其成员值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。
var s = new Set(); // 通过add方法向Set结构中加入成员 [2, 3, 5, 4, 5, 2, 2].map(x =&amp;gt; s.add(x)) for (i of s) { console.log(i) } // 2 3 4 5 （表明set结构不会添加重复的值）   Set结构接收一个数组作为参数，用来初始化。
 var items = new Set([1, 2, 3, 4, 5, 5, 5]); items.size // 5   向Set加入值的时候，不会发生类型转换。这意味着，在Set中5和”5”是两个不同的值。
 Set结构有以下属性：  Set.prototype.constructor: 构造函数，默认就是Set函数。 Set.prototype.size : 返回Set的成员总数。
 Set结构有以下属性：  add(value) : 添加某个值。 delete(value) : 删除某个值。 has(value) : 返回一个布尔值，表示该值是否为Set的成员。 clear() : 清除所有成员。</description>
    </item>
    
    <item>
      <title>页面放大缩小如何保持其宽高比例不变</title>
      <link>https://zhengxiaomengmeng.github.io/2019/05/%E9%A1%B5%E9%9D%A2%E6%94%BE%E5%A4%A7%E7%BC%A9%E5%B0%8F%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E5%85%B6%E5%AE%BD%E9%AB%98%E6%AF%94%E4%BE%8B%E4%B8%8D%E5%8F%98/</link>
      <pubDate>Sat, 11 May 2019 19:30:26 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/05/%E9%A1%B5%E9%9D%A2%E6%94%BE%E5%A4%A7%E7%BC%A9%E5%B0%8F%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E5%85%B6%E5%AE%BD%E9%AB%98%E6%AF%94%E4%BE%8B%E4%B8%8D%E5%8F%98/</guid>
      <description>页面放大缩小如何保持其宽高比例不变 解决方案  使用响应式来做，根据媒体查询，设定在不同屏幕宽度下div的高度和宽度
 使用padding-bottom：XX%大法实现（定义基于父元素宽度的百分比下内边距。此值不会如预期地那样工作于所有的浏览器中。）
 使用vw属性
  实现方案  媒体查询
@media only screen and (min-width: 100px) and (max-width: 640px) { div{ width: 100px; height: 100px; } } @media only screen and (min-width: 641px) and (max-width: 789px) { div{ width: 200px; height: 200px; } }  padding-bottom：XX%大法
  &amp;lt;body&amp;gt; &amp;lt;style&amp;gt; .inner { height: 0; padding-bottom: 25%; overflow: hidden; background-color: red; } &amp;lt;/style&amp;gt; &amp;lt;div style=&amp;quot;width: 50%;&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;inner&amp;quot;&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; 测试&amp;lt;br&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;   使用vw属性，他是参考整个viewport（视窗）的宽度【vw、vh、vmin、vmax是css3新属性，支持主流浏览器且IE10以上】  .</description>
    </item>
    
    <item>
      <title>Axios</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/axios/</link>
      <pubDate>Mon, 29 Apr 2019 21:48:43 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/axios/</guid>
      <description>Axios 问题提出 题目: axios是什么？怎么使用？描述使用它实现登录功能的流程
分析过程  axios是什么？  是基于promise的，用于浏览器和node.js的http客户端，主要作用是向后台发送请求的。
 优势   支持promise 提供一些并发的方法（最大优势） 提供拦截器（相当守卫） 浏览器支持防止CSRF（跨站请求伪造）   axios fetch ajax（jQuery）区别   相同点：都向后台请求数据 区别：前两者基于promise，后者主要还是利用callback的形式 fetch脱离了xhr是新的语法（默认不传cookie 另外不像xhr 可以监听到请求的进度）
  怎么使用？描述使用它实现登录功能的流程  npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</description>
    </item>
    
    <item>
      <title>Vue-router</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/vue-router/</link>
      <pubDate>Mon, 29 Apr 2019 15:15:15 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/vue-router/</guid>
      <description>Vue-router 问题提出 题目: 导航钩子有哪些？他们有哪些参数？
分析过程  导航钩子翻译过来就是路由的生命周期（vue-router）
 其实分成两种 全局和局部
 全局的钩子函数 &amp;gt; beforeEach(在路由切换开始时调用,路由守卫的实现) &amp;gt; afterEach(在路由切换离开时调用)
 局部到单个路由 &amp;gt; beforeEnter
 组件的钩子函数（局部到单个组件） &amp;gt; beforeRouterEnter &amp;gt; beforeRouterUpdate &amp;gt; beforeRouterLeave
 使用的顺序 (组件的钩子函数&amp;gt;局部到单个路由&amp;gt;全局的钩子函数)
   const router = new VueRouter({ routes: routes, }) const routes = [ { path: &#39;/&#39;, name: &#39;/&#39;, component: Home, beforeEnter:function () { //局部到单个路由 } }, { path: &#39;/login&#39;, name: &#39;login&#39;, component: Login }, { path: &#39;/buy&#39;, name: &#39;buy&#39;, component: Buy, meta:{ auth:true } } ] //全局路由 /** to:即将进入目录对象 from:当前导航要离开的导航对象 next:是一个函数调用resolve 执行下一步 */ //实现路由守卫 router.</description>
    </item>
    
    <item>
      <title>Vue基础</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/vue%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 29 Apr 2019 14:47:44 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/vue%E5%9F%BA%E7%A1%80/</guid>
      <description>Vue基础 问题提出 题目: 说出4个vue当中的指令和它的用法
分析过程 1. v-if 条件渲染指令 代码存在销毁
2. v-bind 绑定指令 用来绑定属性 （简写:）
3. v-on 监听事件属性（简写@）
4. v-for 循环指令
5. v-model 数据双向绑定
 v-modle是什么   vue中利用它来进行表单数据的双向绑定（说白了，它只做了两个操作） v-bind绑定了一个value的属性 利用v-on把当前的元素绑定到一个事件上
  Vue中标签怎么绑定事件？  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt; &amp;lt;input v-model=&amp;quot;message&amp;quot;&amp;gt; &amp;lt;p&amp;gt;{{message}}&amp;lt;/p&amp;gt; ------------------------&amp;lt;br/&amp;gt; &amp;lt;input :value=&amp;quot;message2&amp;quot; @input=&amp;quot;message2=$event.target.value&amp;quot;&amp;gt; &amp;lt;p &amp;gt;{{message2}}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &amp;quot; &amp;quot;, message2: &amp;quot; &amp;quot;, } }) &amp;lt;/script&amp;gt;  - 关于Vue
 vue是由饿了么ued团队开发并维护的一个渐进式js框架 vue是一个MVVM的框架</description>
    </item>
    
    <item>
      <title>Vuex</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/vuex/</link>
      <pubDate>Sun, 28 Apr 2019 22:40:25 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/vuex/</guid>
      <description>Vuex学习笔记 问题提出 题目: Vuex是什么？怎么使用？哪种功能场景是用它？
分析过程 1. Vuex是什么
Vuex是一个专门为Vue构建的状态集管理，主要是为了解决组件间状态共享的问题，强调的是集中式管理（说白了,主要是便于维护，便于解耦，所以不是所有的项目都适合使用vuex）如果不是大型项目使用vuex反而使项目代码繁琐多余
2. Vuex的核心
 state（不可缺，存储数据的位置） mutations （不可缺，用来变更状态） getters （类似vue中的computed，动态变更数据） actions （不可缺，动作层，与mutations一起使用，触发状态） modules （拆分state（仓库）方便取数据）  3. 状态集管理的流向
从视图流向actions，actions再commit给mutations，mutations再变更state状态，这三个合在一起就是Vuex，也就是store。
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt; &amp;lt;p&amp;gt;更新技术{{count}}&amp;lt;/p&amp;gt; &amp;lt;button @click=&amp;quot;add&amp;quot;&amp;gt;++&amp;lt;/button&amp;gt; &amp;lt;button @click=&amp;quot;reduce&amp;quot;&amp;gt;--&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var store = new Vuex.Store({ state: { count: 0 }, mutations: { //唯一一个可以更改状态的地方 addState: function (state) { if (state.count &amp;lt; 59) { state.count++; } else { state.count = 0; } }, reduceState: function (state) { if (state.</description>
    </item>
    
    <item>
      <title>错误监控类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E7%B1%BB/</link>
      <pubDate>Sun, 28 Apr 2019 18:45:33 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E7%B1%BB/</guid>
      <description>错误监控类 问题提出 题目: 错误监控类有哪些或者如何保证产品质量？？
分析过程 需要掌握得知识点
 前端错误的分类
 错误的捕获方式
 上报错误的基本原理
  1.前端错误的分类
 即时运行错误：代码错误
 资源加载错误：（js、css、图片加载失败）
  2.错误的捕获方式
 即时运行错误： try…catch(需要把try&amp;hellip;catch布到代码中) window.onerror(dom0)只能捕获即时运行错误
  **资源加载错误：（js、css、图片加载失败）** object.onerror(通过节点绑onerror事件，捕获加载错误；) performance.getEntries(); 获取已加载资源时长，通过这个方式可以间接的拿到没有加载资源的错误； 返回的是一个数组，有forEach方法。 performance.getEntries().forEach(item=&amp;gt;{console.log(item.name)});可以得到已成功加载的资源。 document.getElementsByTagName(‘img’);能拿到所有img的一个集合，是我们所需要加载的所有 图片的一个集合减去上面已成功加载的集合，剩下就是没有成功加载的。 Error事件捕获 window上通过事件捕获一样可以拦截到资源加载错误。可以在捕获阶段拿到这个。 body中: &amp;lt;script src=“//baidu.com/test.js” charset=“utf-8”&amp;gt;&amp;lt;/script&amp;gt;//不存在 为了证明捕获可以拿到这个事件； head中： &amp;lt;script&amp;gt; window.addEventListener(‘error’,function(e){ conosle.log(‘捕获’,e); }); &amp;lt;/script&amp;gt; ==&amp;gt;报错 GETfiles | baidu.com | test.js 没找到 捕获 Event {isTrusted:true,’type’:’error’,target:script,currentTarget:window,eventphase:1…} 不会冒泡，script标签发生了错误，触发本身onerror事件已经可以了，不会向上冒泡到window。  延伸：跨域JS运行错误可以捕获吗，错误提示是什么，应该怎么处理？ 可以拿到所有跨域文件的代码错误；
Resource interpreted as script but transferred 错误信息：Script error.</description>
    </item>
    
    <item>
      <title>JS页面性能类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/js%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E7%B1%BB/</link>
      <pubDate>Sun, 28 Apr 2019 15:20:46 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/js%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E7%B1%BB/</guid>
      <description>JS页面性能类 问题提出 题目: 提升页面性能的方法有哪些？
分析过程 需要掌握得知识点
 资源压缩合并，减少HTTP请求
 非核心的代码异步加载—异步加载的方式—异步加载的区别
 利用浏览器缓存—缓存的分类—缓存的原理
 使用CDN（网络优化，CDN加载资源非常快）
 预解析DNS ```    **1.资源压缩合并，减少HTTP请求** 资源传输的过程变小 **2.非核心的代码异步加载—异步加载的方式—异步加载的区别** 异步加载的方式： &amp;gt; **1.动态脚本加载** —js创建了一个标签，把标签最后加到body上去或者head（加到文档当中实现加载） document.createElement(“*”); **2.defer** **3.async** **怎么用：** 在加载js时候在script标签上加这两个属性完成异步加载； **异步加载的区别：** &amp;gt; 1.defer是在HTML解析完之后才会执行，如果是多个，按照加载顺序依次执行； 2.async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关； **异步加载原理：**（任何一个时刻都只能做一件事） &amp;gt; 1.defer：新加载的，在HTML解析完之前，是不会执行的；defer能保证按你的加载顺序依次执行； 2.async：哪个先回来，哪个先执行，和加载顺序无关； **3.利用浏览器缓存—缓存的分类—缓存的原理** - 缓存的分类： &amp;gt; **缓存：** 对应文件在浏览器中存在的备份（副本），把请求的东西缓存到本地了（是放在电脑磁盘中的），浏览器下次请求相当于是从这个磁盘直接读了，而不会再去请求这个文件的地址。 **1. 强缓存**  http协议头： Expires Expires:Thu,21 Jan 2017 23:39:02 GMT Cache-Control Cahe-Control : Max-age=3600
 &amp;gt; **强缓存**：问都不问，不直接请求，直接拿过来就用了；不管是绝对时间还是相对时间，这个时间过期之前不会和服务器通信了，直接从浏览器副本拿出来给页面用； ``` HTTP协议头： 在请求一个文件的时候，http头上（响应头上）会带两个东西（有可能是2个，也有可能是1个，根据服务器配置）； 响应头中会有key，value Expires 过期时间； value值表示的是绝对时间（服务器的绝对时间，这个时间是服务器下发的） 判断客户端当前的时候是不是这个时间，比较的时候是按浏览器本地的时间做比较，下发的是服务器端的时间，会有偏差； 缺点：有可能客户端和服务器的时间不一致。 Cache-Control value值 Max-age=3600（相对时间） 不管客户端和服务器时间是否一致，它最后是以客户端相对时间为止，时间单位是秒（拿到资源之后再3600s之内不会再去请求服务器，在这个时间之内直接去浏览器拿缓存） *如果服务器两个时间都下发了，依哪个时间为准呢？ 以后者相对时间为准（这个规定）  2.</description>
    </item>
    
    <item>
      <title>渲染机制</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 28 Apr 2019 13:07:11 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</guid>
      <description>渲染机制 问题提出 题目: 渲染机制问题
分析过程 需要掌握得知识点
 什么是DOCTYPE及作用
 浏览器渲染过程
 重排(Reflow)
 重绘(Repaint)
 布局(layout)
  1.什么是DOCTYPE及作用
 DTD（document type definition,文档类型定义）是一系列的语法规则，用来定义XML或（X）HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。（DTD就是告诉浏览器我是什么文档类型，浏览器根据这个判断用什么引擎来解析和渲染它） DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错；（DOCTYPE就是直接告诉浏览器什么是DTD的，通知浏览器告诉当前的文档包含的是哪个DTD， 也就是哪个文档类型。）
  常见的DOCTYPE有哪些？   HTML5 &amp;lt;!DOCTYPE html&amp;gt; HTML 4.01 Strict(严格模式) （该DTD包含所有HTML元素和属性，但不包括展示性的和弃用的元素--比如：font） &amp;lt;!DOCTYPE HTML PUBLIC&amp;quot;-//W3C//DTD HTML 4.01//EN&amp;quot; &amp;quot;http://www.w3.org/TR/html4/strict.dtd&amp;quot;&amp;gt; HTML 4.01 Transitional（传统模式--宽松模式） (该DTD包含所有HTML元素和属性，包括展示性的和弃用的元素--比如font) &amp;lt;!DOCTYPE HTML PUBLIC&amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;  当问到此题时，说出HTML5的具体用法和HTML4的严格模式和传统模式以及这两种模式的特点，其他可以不用说。
2.浏览器渲染过程
 html css js三个都会影响页面最后的呈现形式（*浏览器拿到html，css之后要干什么？） 浏览器渲染过程？ 1.把html经过HTML Parser也就是DOM Parser转成DOM Tree（dom树）； 2.css按照css规则和css解释器转成css Rules（cssOM Tree）； 3.</description>
    </item>
    
    <item>
      <title>算法类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E7%AE%97%E6%B3%95%E7%B1%BB/</link>
      <pubDate>Sat, 27 Apr 2019 22:54:22 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E7%AE%97%E6%B3%95%E7%B1%BB/</guid>
      <description>算法类 问题提出 题目: 算法类问题
分析过程 需要掌握得知识点
 排序
 堆栈、队列、链表
 递归
 波兰式和逆波兰式
  1. 排序(重要)
 冒泡排序
 快速排序(重要) &amp;gt; https://segmentfault.com/a/1190000009426421
 选择排序(重要) &amp;gt; https://segmentfault.com/a/1190000009366805
 希尔排序(重要) &amp;gt; https://segmentfault.com/a/1190000009461832
  2.堆栈(重要)、队列、链表
 &amp;ndash;JS数组本身就是具备堆栈，队列的特性； pop、push、shift、unshift 这个四个api已经帮我们实现堆栈和队列；
堆栈：先进后出；可以让unshift进，pop出； https://juejin.im/entry/58759e79128fe1006b48cdfd 队列： https://juejin.im/entry/58759e79128fe1006b48cdfd 链表： https://juejin.im/entry/58759e79128fe1006b48cdfd
 3.递归(重要)（60%算法题都要用到递归）
 https://segmentfault.com/a/1190000009857470
 递归的终止条件和参数传递？
4.波兰式和逆波兰式 eg：(1+35)(4+63&amp;frasl;2)用js来写怎么去实现最后的结果？ 理论： http://www.cnblogs.com/chenying99/p/3675876.html 源码： https://github.com/Tairraos/rpn.js/blob/master/rpn.js</description>
    </item>
    
    <item>
      <title>安全类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E5%AE%89%E5%85%A8%E7%B1%BB/</link>
      <pubDate>Sat, 27 Apr 2019 21:03:28 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E5%AE%89%E5%85%A8%E7%B1%BB/</guid>
      <description>安全类 问题提出 题目: 安全类问题
分析过程 需要掌握得知识点
 CSRF(基本概念和缩写、攻击原理、防御措施)
 XSS
  1.CSRF
 基本概念和缩写   跨站请求伪造；Cross-Site Request Forgery 缩写CSRF
  攻击原理   1.用户是网站A的注册用户，通过身份验证登录网站A，登录之后网站A核查身份是不是正确的，如果正确就下发cookie，这个cookie保存到用户浏览器当中，这就是完成了一次身份认证的过程。 2.用户又访问了一个网站B，网站B会给用户下发用户页面的时候，会存在引诱的一个点击，这个点击往往是一个链接，就是指向网站A的一个API接口，接口是GET类型，比如：www.xxx.com/hack， 指向存在漏洞的接口，当用户经不住引诱点击了这个东西，这个点击就访问了A网站，访问A网站这个链接的时候，浏览器会自动上传cookie，上传之后网站A觉得是A这个Cookie拿过来之后对身份重新认证，发现是合法用户，就执行了这个接口的动作。
 重点：用户在注册网站登录过，没有登录会提示登录；
CSRF能够造成攻击的原理：（实现CSRF攻击不可缺失的连个因素）
1.网站中某一个接口存在漏洞 2.这个用户在注册网站确实登录过
 防御措施  访问接口的时候，浏览器自动上传cookie，但是没有手动上传一个Token，这个Token是你注册成功以后，或者没有注册，只要你访问了这个网站，服务器会自动的向你本地存储一个Token，在你访问各种接口的时候，如果没带Token,,就不能帮你通过验证，如果只是点击了引诱链接，这个链接只会自动携带cookie，不会自动携带Token，所以就避免了那个攻击。 2.Referer验证 Referer指的是页面来源，如果服务器判断页面来的是不是我的这个站点下面的页面，如果是就执行你这个动作，如果不是就拦截。 3.隐藏令牌 和Token有点像，做法：隐藏在http的head头中，不会放在链接上，这样就做的比较隐蔽。本质上没 有太大区别。只是使用方式有一点差别。  2.XSS
 基本概念和缩写:   跨域脚本攻击；Cross-Site Scripting 缩写XSS
  攻击原理（核心宗旨：让你插入的js不可执行）   http://www.immoc.com/learn/812
  防御措施   http://www.immoc.com/learn/812
  和CSRF区别 &amp;gt; XSS不需要做任何的登录认证，核心原理向你页面注入脚本； eg：比如评论区：如果评论区注入XSS最好的方式可以在你提交区里面写上script标签，img标签上加事件，总之，它的方法利用你合法的渠道向你页面注入js，这是XSS攻击原理。 XSS是向你页面注入js运行，然后js函数体里面做它想做的事情。 CSRF利用你本身的漏洞，去帮你自动执行那些接口。  &amp;mdash;&amp;mdash;这两种攻击方式是不一样的，CSRF要依赖用户要登录网站。</description>
    </item>
    
    <item>
      <title>通信类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E9%80%9A%E4%BF%A1%E7%B1%BB/</link>
      <pubDate>Sat, 27 Apr 2019 13:41:44 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E9%80%9A%E4%BF%A1%E7%B1%BB/</guid>
      <description>通信类 问题提出 题目: 通信类问题
分析过程 需要掌握得知识点
 什么是同源策略及限制
 前后端如何通信
 如何创建Ajax
 跨域通信的几种方式
  1.什么是同源策略及限制
 1.同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。 ( 这是一个用于隔离潜在恶意文件的关键的安全机制。) 2.一个源包括：协议、域名、端口 （这三个有一个不一样就是源不一样，就是我们所说的跨域了） http:// 协议 www.xxx.com 域名 没指名端口默认80 3.限制：不是一个源的文档没有权利去操作另一个源的文档；
 主要限制在几个方面：
 Cookie、LocalStorage 和 IndexDB 无法读取 &amp;ndash;操作不了Cookie、LocalStorage、IndexDB
 DOM无法获得 &amp;ndash;无法获取和操作另一个资源的DOM
 Ajax请求不能发送（同源下的通信方式） &amp;ndash;Ajax只适合同源的通信（跨域就不行了）
  2.前后端如何通信
 1、Ajax &amp;ndash;同源下的通信方式 2、WebSocket &amp;ndash;不受同源策略的限制 3、CORS &amp;ndash;支持跨域通信，也支持同源通信
 3.如何创建Ajax
 1、XMLHttpRequest对象的工作流程 2、兼容性处理 3、事件的触发条件 4、事件的触发顺序
  function ajax(url,fnSucc,fnFaild){ //1、创建一个对象（兼容IE6写法） var xhr = XMLHttpRequest ?</description>
    </item>
    
    <item>
      <title>面向对象</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 26 Apr 2019 14:33:27 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>面向对象 问题提出 题目: 面向对象问题
分析过程 需要掌握得知识点
 类与实例（类的声明、生成实例）
 类与继承（如何实现继承、继承的几种方式）
  1.类与实例
1.1.类的声明 eg: 1. function Animal(){ this.name = &amp;quot;name&amp;quot;; } 2.ES6中类(class)的声明 class Animal2{ constructor(){ this.name = name; } } 1.2.(如何通过类实例化生成对象)生成实例 eg: //如果构造函数后面没有参数，new后面这个()是可以不要的； 1.console.log(new Animal(),new Animal2());  2.类与继承
问题
 如何实现继承？ 继承的几种方式、各个形式都有什么优点和缺点？   继承的本质（原理**）就是原型链。
 借助构造函数实现继承   （只实现了部分继承，如果父类的属性都在构造函数上，那没有问题； 如果父类的原型对象上还有方法，子类是拿不到这些方法的） function Parent1(){ this.name = &amp;quot;parent1&amp;quot;; } function Child(){ //call和apply改变的是函数运行上下文，把父级（Parent1这个构造函数）在子函数里执行的话， 同时修改了父级构造函数this的指向，从而导致了父类执行的时候属性都会挂在Child类实例上去。 //将父级的构造函数的this指向一个子构造函数的实例上去，父级构造函数所有的属性在子类中也有 Parent1.call(this); this.type=&amp;quot;child1&amp;quot;; } console.log(new Child()); 缺点：Parent1原型链上的东西并没有被Child所继承； 没有继承父类原型对象上的方法，导致的并没有真正的实现继承； function Parent1(){ this.</description>
    </item>
    
    <item>
      <title>原型链类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%B1%BB/</link>
      <pubDate>Thu, 25 Apr 2019 16:07:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%B1%BB/</guid>
      <description>原型链类 问题提出 题目:原型链类
分析过程 需要掌握得知识点
 创建对象的几种方法
 原型、构造函数、实例、原型链
 instanceof的原理
 new 运算符
  1.创建对象的几种方法
 字面量 构造函数 Object.create  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; // 第一种方式：字面量 var o1 = { name: &amp;quot;o1&amp;quot; }; var o2 = new Object({ name: &amp;quot;o2&amp;quot; }); // 第二种方式：构造函数 var M = function(name) { this.name = name; }; var o3 = new M(&amp;quot;o3&amp;quot;); // 第三种方式：Object.create var p = { name: &amp;quot;p&amp;quot; }; var o4 = Object.</description>
    </item>
    
    <item>
      <title>HTTP协议类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/http%E5%8D%8F%E8%AE%AE%E7%B1%BB/</link>
      <pubDate>Wed, 24 Apr 2019 22:28:11 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/http%E5%8D%8F%E8%AE%AE%E7%B1%BB/</guid>
      <description>HTTP协议类 问题提出 题目: HTTP协议类一面需要掌握知识
分析过程 需要掌握得知识点
 HTTP协议的主要特点
 HTTP 报文的组成部分
 HTTP方法
 POST和GET的区别
 HTTP状态码
 持久连接
 管线化
  1.HTTP协议的主要特点
 简单快速 每个资源URI(统一资源符)是固定的，比如图片、页面地址，所以HTTP协议中处理比较简单，访问某个资源输入URI即可 灵活 每个http协议中。有一个头部分，有个数据类型，通过一个http协议的就可以完成不同数据类型的传输 无连接 (重点) 连接一次就会断开，不会保持连接 无状态 (重点) 客户端和服务端两种身份，客户端向服务端请求一个图片，http帮你建立连接、传输结束后，连接断开，下次客户端在请求数据，服务端是无法区分上次连接和这次连接是否是同一身份，因为服务端没有记住你的状态，单从http协议上是无法区分两次连接者的身份  状态区分是通过服务端加一下session做到的
2.HTTP 报文的组成部分
- 请求报文
 请求行:http方法、页面地址、协议、版本
 请求头:key、value告诉服务端需要内容，注意什么类型
 空行:告诉服务端请求头已经结束
 请求体
  - 响应报文
 状态行:协议、版本、状态码
 响应头
 空行
 响应体:文档部分
  3.HTTP方法
 GET 获取资源
 POST 传输资源</description>
    </item>
    
    <item>
      <title>DOM事件类</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/dom%E4%BA%8B%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Tue, 23 Apr 2019 22:43:59 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/dom%E4%BA%8B%E4%BB%B6%E7%B1%BB/</guid>
      <description>DOM事件类 问题提出 题目: DOM事件类
分析过程 需要掌握得知识点
 基本概念：DOM事件的级别
 DOM事件模型
 DOM事件流
 描述DOM事件捕获的具体流程
 Event对象的常见应用
 自定义事件
  1.DOM事件的级别
DOM0：element.onclick=function(){}
DOM1设定的时候没有设计跟事件相关的事件
DOM2：element.addEventListener(&amp;lsquo;click&amp;rsquo;,fuction(){},false)
DOM3：element.addEventListener(&amp;lsquo;keyup&amp;rsquo;,fuction(){},false) （事件类型增加了）
2.DOM事件模型
捕获和冒泡
3.DOM事件流
浏览器在为当前页面与用户做交互的过程中，是怎么响应的
*完整的事件流*：1、捕获 2、目标阶段 3、冒泡
4.描述DOM事件捕获的具体流程
window&amp;ndash;&amp;gt;document&amp;ndash;&amp;gt;html&amp;ndash;&amp;gt;body&amp;ndash;&amp;gt;&amp;hellip;&amp;ndash;&amp;gt;目标元素 （其中获取html节点用document.documentElement，获取body节点用document.body）
冒泡则是反过来的 var ev = document.getElementById(&#39;ev&#39;); window.addEventListener(&#39;click&#39;,function(){ console.log(&#39;window capture&#39;) },true)//true是捕获，false是冒泡 document.addEventListener(&#39;click&#39;,function(){ console.log(&#39;document capture&#39;) },true) document.documentElement.addEventListener(&#39;click&#39;,function(){ console.log(&#39;html capture&#39;) },true) document.body.addEventListener(&#39;click&#39;,function(){ console.log(&#39;body capture&#39;) },true) ev.addEventListener(&#39;click&#39;,function(){ console.log(&#39;ev capture&#39;) },true)  5.Event对象的常见应用
event.preventDefault() （阻止默认事件） event.stopPropagation() （阻止冒泡行为） event.stopImmediatePropagation() （假如同一个button创建了两个click事件，要执行A不执行B，就用这个方法） event.</description>
    </item>
    
    <item>
      <title>CSS盒子模型的联想</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%81%94%E6%83%B3/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%81%94%E6%83%B3/</guid>
      <description>CSS盒子模型的联想 问题提出 题目:谈谈你对CSS盒子模型的认识。
分析过程 需要掌握得知识点 基本概念：标准模型+ IE模型(区别) CSS如何设置这两种模型 JS如何设置获取盒子模型对应的宽和高 实例题(根据盒模型解释边距重叠) BFC(边距重叠解决方案)
1. 基本概念：标准模型+ IE模型(区别) 从上图可以看到标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。
从上图可以看到 IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。
2. CSS如何设置这两种模型 box-sizing:conent-box;（默认）标准的盒子模型 box-sizing:border-box;IE盒子模型
3. JS如何设置获取盒子模型对应的宽和高 dom.style.width/height（获取内联节点的宽高） dom.currentStyle.width/height (ie支持) window.getComputedStyle(dom).width/height;（都支持，兼容性更好） dom.getBoundingClientRect().width/height;（计算圆速的绝对定位，可以返回四个值：left，right，top，bottom，从而计算出宽高）。
4. 实例题(根据盒模型解释边距重叠) 问题：如上图有两个元素其中子元素高度为100px,子元素与父元素的上边距为 10px,求父元素的实际高度？
答案:说100px 对，说110px 也对，为什么捏？这个要看父元素的盒模型要怎么设置的，上代码演示咯，注意看噢：
&amp;lt;style&amp;gt; html,*{ padding: 0;margin: 0; } #sec{ background: #f00; } .child{ height: 100px; margin-top: 10px; background: yellow; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;section id=&amp;quot;sec&amp;quot;&amp;gt; &amp;lt;article class=&amp;quot;child&amp;quot;&amp;gt; &amp;lt;/article&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;/body&amp;gt;  上图证明 100px 是对的。</description>
    </item>
    
    <item>
      <title>三栏布局实现方案及其比较</title>
      <link>https://zhengxiaomengmeng.github.io/2019/04/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%8F%8A%E5%85%B6%E6%AF%94%E8%BE%83/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/04/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%8F%8A%E5%85%B6%E6%AF%94%E8%BE%83/</guid>
      <description>三栏布局实现方案及其比较 问题提出 假设高度已知，请写出三栏布局，左栏、右栏宽度300px，中间宽度自适应。
分析过程 这道题本身的难度并不大，我们在布局页面的时候，写个三栏布局还是挺简单的。但是如果在面试的时候遇到这道题，就没有那么简单了。看似简单的一道题，想把它答好是不简单的。往往越简单的题越不好答。如果看到这题只想到了float和absolute，那这题你连及格都及格不了。
实现过程 下面有5种三栏布局方式，先设置最初的样式。
&amp;lt;style&amp;gt; html, * { padding: 0; margin: 0; } .layout article div { min-height: 100px; } .layout{ margin-top: 20px; } &amp;lt;/style&amp;gt;  1.float布局
&amp;lt;section class=&amp;quot;layout float&amp;quot;&amp;gt; &amp;lt;style media=&amp;quot;screen&amp;quot;&amp;gt; .layout.float .left { float: left; width: 300px; background: #45ff96; } .layout.float .right { float: right; width: 300px; background: #bce8f1; } .layout.float .center { /*min-height: 100%;*/ background: #e7f1a6; } &amp;lt;/style&amp;gt; &amp;lt;article class=&amp;quot;left-right-center&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt; &amp;lt;h1&amp;gt;浮动解决方案&amp;lt;/h1&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>JavaScript堆栈原理</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/javascript%E5%A0%86%E6%A0%88%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 07 Mar 2019 22:31:13 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/javascript%E5%A0%86%E6%A0%88%E5%8E%9F%E7%90%86/</guid>
      <description>JavaScript堆栈原理 堆&amp;amp;栈 两者都是用来存放临时数据。
栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。
堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。
栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。
堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
栈（数据结构）：一种先进后出的数据结构。
数据类型访问&amp;amp;&amp;amp;复制 基本数据类型：基本数据类型值指保存在栈内存中的简单数据段。访问方式是按值访问。
 var a =1 ;
 栈内存  a 1        操作的是变量实际保存的值。当a = 2时，栈内存的1直接改成2。
 基本类型变量的复制：从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上。
 var b=a;
 栈内存  a 1  b 1    var b=2; //把栈中b所对应的值改成2，a的值不变，仍然是1；
 引用数据类型：引用数据类型值指保存在堆内存中的对象。也就是，变量中保存的实际上的只是一个指针，这个指针指向内存中的另一个位置，该位置保存着对象。访问方式是按引用访问。
 var a = new Object(); //(引用指针指向object)
 栈内存  堆内存  a 引用指针 object            当操作时，需要先从栈中读取内存地址，然后再延指针找到保存在堆内存中的值再操作。</description>
    </item>
    
    <item>
      <title>各种布局的优缺点</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/%E5%90%84%E7%A7%8D%E5%B8%83%E5%B1%80%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/%E5%90%84%E7%A7%8D%E5%B8%83%E5%B1%80%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</guid>
      <description>各种布局的优缺点 这篇博客讲的非常详细</description>
    </item>
    
    <item>
      <title>各种布局优缺点</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/%E5%90%84%E7%A7%8D%E5%B8%83%E5%B1%80%E4%BC%98%E7%BC%BA%E7%82%B9/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/%E5%90%84%E7%A7%8D%E5%B8%83%E5%B1%80%E4%BC%98%E7%BC%BA%E7%82%B9/</guid>
      <description> Grid(网格) 布局 CSS Grid(网格) 布局（又称为 “Grid(网格)” ），是一个二维的基于网格的布局系统，它的目标是完全改变我们基于网格的用户界面的布局方式。
Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局，而不是复杂的二维布局（实际上 Flexbox 和 Grid 能协同工作，而且配合得非常好）。
 静态布局 传统布局，屏幕宽高变化时，盒子使用横向或者竖向的滚动条来查看被遮挡部分，也就是不管浏览器窗口的大小怎么变化就按html语义标签排列的布局来布置。 弹性布局 css3引入的，flex布局；优点在于其容易上手，根据flex规则很容易达到某个布局效果，然而缺点是：浏览器兼容性比较差，只能兼容到ie9及以上； 自适应布局 分别为不同的屏幕分辨率定义布局，在每个布局中，页面元素不随窗口大小的调整而发生变化，当窗口大小到达一定分辨率时变化一次。 流式布局 页面元素的宽度按照屏幕进行适配调整，元素的位置不变，大小变化，屏幕太大或者太小导致元素不能正常显示。 响应式布局 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;divice-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&amp;quot;&amp;gt;
使用meta标签设置，页面元素宽度随窗口调整自动适配。主要属性及其含义如下：name=&amp;ldquo;viewport&amp;rdquo;： 名称=视图；width=device-width 页面宽度=设备宽度(可以理解为获取你手机的屏幕宽度)；initial-scale - 初始的缩放比例；minimum-scale - 允许用户缩放到的最小比例 ；maximum-scale - 允许用户缩放到的最大比例 ；user-scalable - 用户是否可以手动缩放 。
 网格布局：grid二维布局系统，随意的定义每行每列的数目和大小。也非常简单方便，兼容性较差。   </description>
    </item>
    
    <item>
      <title>meta viewport设置移动端自适应</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/meta-viewport%E8%AE%BE%E7%BD%AE%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/meta-viewport%E8%AE%BE%E7%BD%AE%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94/</guid>
      <description> meta viewport设置移动端自适应 viewport 移动设备上的viewport是设备屏幕上用来显示网页的那部分区域，再具体一点就是浏览器上用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。在默认情况下，移动设备上的viewport都是大于浏览器可视区域的，这是因为移动设备的分辨率相对于PC来说都比较小，所以为了能在移动设备上正常显示那些为PC浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，由设备本身决定），但后果是浏览器出现横向滚动条，因为浏览器可视区域的宽度比默认的viewport的宽度小。
3个viewport （1）layout viewport
如果把移动设备上浏览器的可视区域设为viewport的话，某些网站会因为viewport太窄而显示错乱，所以这些浏览器就默认会把viewport设为一个较宽的值，比如980px，使得即使是那些为PC浏览器设计的网站也能在移动设备浏览器上正常显示。这个浏览器默认的viewport叫做 layout viewport。layout viewport的宽度可以通过 document.documentElement.clientWidth来获取。
（2）visual viewport
layout viewport的宽度是大于浏览器可视区域的宽度的，所以还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做 visual viewport。visual viewport的宽度可以通过 document.documentElement.innerWidth来获取。
（3）ideal viewport
ideal viewport是一个能完美适配移动设备的viewport。首先，不需要缩放和横向滚动条就能正常查看网站的所有内容；其次，显示的文字、图片大小合适，如14px的文字不会因为在一个高密度像素的屏幕里显示得太小而无法看清，无论是在何种密度屏幕，何种分辨率下，显示出来的大小都差不多。这个viewport叫做 ideal viewport。
ideal viewport并没有一个固定的尺寸，不同的设备有不同的ideal viewport。例如，所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640。
ideal viewport 的意义在于，无论在何种分辨率的屏幕下，针对ideal viewport 而设计的网站，不需要缩放和横向滚动条都可以完美地呈现给用户。
利用meta标签对viewport进行控制 移动设备默认的viewport是layout viewport，，但在进行移动设备网站的开发时，需要的是ideal viewport。要得到ideal viewport，需要用到meta标签。
head标签中加入：
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&amp;quot;&amp;gt;  该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。当然maximum-scale=1.0, user-scalable=0不是必需的，是否允许用户手动播放根据网站的需求来定，但把width设为width-device基本是必须的，这样能保证不会出现横向滚动条。 width能控制layout viewport的宽度，如果不指定该属性，layout viewport将默认为980px或1024px（也可能是其它值，由设备本身决定），如果把layout viewport的宽度设置为移动设备的宽度，那么layout viewport将成为ideal viewport。
其实，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置width=device-width，也可以设置initial-scale=1，但有一个小缺陷，就是width=device-width会导致iphone、ipad横竖屏不分，initial-scale=1会导致IE横竖屏不分，都以竖屏的ideal viewport宽度为准。所以，最完美的写法两者都写上去， initial-scale=1 解决 iphone、ipad的缺陷，width=device-width解决IE的缺陷。
viewport设置移动端自适应的方法：
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;  </description>
    </item>
    
    <item>
      <title>浮动元素引起的问题和解决办法</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>浮动元素引起的问题和解决办法 问题  多个浮动的元素无法撑开父元素的宽度，父元素的高度可能会变成0。 若浮动元素后面跟非浮动元素，非浮动元素会紧随其后浮动起来。 若浮动元素前面还有同级元素没有浮动则会影响页面结构。  解决办法  clear:both 在最后一个浮动元素后面添加属性为clear:both;的元素。  &amp;lt;style&amp;gt; div.parent&amp;gt;div.fl{ float: left; width: 200px; height: 200px; margin-right: 20px; border: 1px solid red; } .clear{ clear: both; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;quot;parent&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;clear&amp;quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;  给父元素添加clear:both;属性的:after伪元素。
&amp;lt;style&amp;gt; div.parent&amp;gt;div.fl{ float: left; width: 200px; height: 200px; margin-right: 20px; border: 1px solid red; } .clear:after{ content: &#39;&#39;; display: block; clear: both; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;quot;parent clear&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;fl&amp;quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;  注意：伪元素默认是内联水平，所以借助伪元素时要设置属性display: block;。</description>
    </item>
    
    <item>
      <title>css js文件放置位置和原因</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/css-js%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/css-js%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%8E%9F%E5%9B%A0/</guid>
      <description>css js文件放置位置和原因 js文件最好放在body中，也就是标签前，因为放在所有body中的标签后面就不会出现网页加载时出现空白的情况，可以持续的给用户提供视觉反馈，同时在有些情况下，会降低错误的发生。
而css标签应该放在标签之间，因为如果放在标签的前面，那么当DOM树构建完成了，渲染树才构建，那么当渲染树构建完成，浏览器不得不再重新渲染整个页面，这样造成了资源的浪费。效率也不高。如果放在之间，浏览器边构建边渲染，效率要高的多。</description>
    </item>
    
    <item>
      <title>IE中常见BUG（兼容性问题）</title>
      <link>https://zhengxiaomengmeng.github.io/2019/03/ie%E4%B8%AD%E5%B8%B8%E8%A7%81bug%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/03/ie%E4%B8%AD%E5%B8%B8%E8%A7%81bug%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</guid>
      <description>https://www.cnblogs.com/songzk/p/6181641.html</description>
    </item>
    
    <item>
      <title>css实现水平、垂直居中</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</guid>
      <description>css实现水平、垂直居中 元素水平居中 块级元素水平居中 最简单的方式：margin： 0 auto; 注意点 (1)元素需要设置宽度 (2)元素不能为行内元素
行内元素水平居中 元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。（对于块级元素不起作用）
不定宽度的块状元素有三种方法居中（这三种方法目前使用的都比较多）： 1.加入 table 标签 第一步：为需要设置的居中的元素外面加入一个 table 标签 ( 包括 、、 ) 第二步：为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样）
&amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;不定宽块状元素水平居中&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; table{ margin:0 auto; } ul{list-style:none;margin:0;padding:0;} li{float:left;display:inline;margin-right:8px;} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt; &amp;lt;table&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  2.设置 display;inline 方法 改变块级元素的 dispaly 为 inline 类型，然后使用 text-align:center 来实现居中效果。</description>
    </item>
    
    <item>
      <title>css实现隐藏页面的方式</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/css%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/css%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>css实现隐藏页面的方式 opacity 设置透明度，值为0-1。为0则页面上不显示，但是元素还在那个位置,依然可以网页交互,单纯是看不到而已。在呈现上与visibility:hidden;方式一样，同样会占据页面空间。
.class{ opacity:0; }  visibility 设置隐藏。hidden为隐藏，在页面不显示，交互效果也会没有。visible为显示,hidden为隐藏。该方法仍占用页面空间，但是不会导致浏览器重排，但是会重绘。
.class{ visibility:hidden;//隐藏 visibility:visible;//显示 }  display 设置不显示和显示。注意了，这里要强调的一点是，如果你想使他的子元素显示，用display:visible是没用的。而上面两种方式是可以使用。该方法不占用空间，会导致浏览器的重排和重绘。
.class { display:none; }  position position位置，用绝对定位把它挪到远远地。
.class{ position:absolute; left:-999px; top:-999px; }  Clip-path 该属性很少见，该属性是通过裁剪的方法实现隐藏的。被隐藏的内容依然占据着那个位置，它周围的元素的行为就如同它可见时一样。记住用户交互例如鼠标悬停或者点击在剪裁区域之外也不可能生效。此外，这个属性能够使用各种过渡动画来实现不同的效果。
.haorooms-small { background-size: cover; width: 300px; height: 300px; -webkit-clip-path: polygon(0% 50%, 25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%); clip-path: polygon(0% 50%, 25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%); }  &amp;lt;div class=&amp;quot;haorooms-small&amp;quot; style=&amp;quot;background-image: url(&#39;http://sandbox.</description>
    </item>
    
    <item>
      <title>display、position的属性和作用</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/displayposition%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/displayposition%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%9C%E7%94%A8/</guid>
      <description>display、position的属性和作用 display 的值的作用： 1.block 像块类型元素一样显示。 2.inline 像行内元素类型一样显示。 3.inline-block 像行内元素一样显示，但其内容像块类型元素一样显示。 4.list-item 像块类型元素一样显示，并添加样式列表标记。
position 的值的定位区别： 1.absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。 2.fixed 生成绝对定位的元素，相对于浏览器窗口进行定位（老IE不支持）。 3.relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 4.static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 5.inherit 规定从父元素继承 position 属性的值。</description>
    </item>
    
    <item>
      <title>meta标签</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/meta%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/meta%E6%A0%87%E7%AD%BE/</guid>
      <description>meta标签使用总结</description>
    </item>
    
    <item>
      <title>盒子模型 box-sizing</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B-box-sizing/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B-box-sizing/</guid>
      <description>盒子模型 box-sizing 盒子模型 盒子模型由元素内容(content)、元素的内边距(padding:内容与边框之间的距离)，元素的边框(border)，元素的外边距(margin:边框与外部元素之间的距离)四个部分，这四个部分一起构成了盒子模型。
对于padding、margin的取值 （注意：不允许取负值）
注意：margin重叠，也叫 margin塌陷
标准文档流中，两个盒子，分别有上下外边距，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的)。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;margin叠加&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; *{ padding: 0; margin: 0; } .a{ width: 100px; height: 100px; border:1px solid; background-color: teal; margin-bottom: 10px; } .b{ width: 100px; height: 100px; border:1px solid; background-color: red; margin-top: 20px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;quot;a&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;b&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  注意：上下两个盒子的距离不是30px；而是20px，上面两个盒子的margin值不叠加，只取较大的值作为margin。
另外：margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。
如果向设置父子之间的距离，我们最好使用父元素的padding。
box-sizing box-sizing 属性允许以特定的方式定义匹配某个区域的特定元素,简单来说就是可以通过box-sizing的取值来切换盒模型，它的取值可以为content-box、border-box.默认属性是content-box。
W3C标准盒子（content-box）：又称内容盒子，是指块元素box-sizing属性为content-box的盒模型。一般在现代浏览器中使用的都是正常盒模型content-box。它所说的width一般只包含内容，不包含padding与margin，并且盒子的大小会以内容优先，自动扩展，子元素可以撑开父元素.可以理解为现实生活中的气球，大小可以随内容的变化而变化。
 在这种盒模型下，我们所说的元素的 width ，实际上只包含 content。盒子总宽度 = margin + border + padding + width</description>
    </item>
    
    <item>
      <title>使用data-的好处</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E4%BD%BF%E7%94%A8data-%E7%9A%84%E5%A5%BD%E5%A4%84/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E4%BD%BF%E7%94%A8data-%E7%9A%84%E5%A5%BD%E5%A4%84/</guid>
      <description>使用data-的好处  data-* 属性用于存储页面或应用程序的私有自定义数据。
 data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。
  存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。
 data-* 属性包括两部分：  (1) 语法 1. 属性名不应该包含任何大写字母，并且在前缀 &amp;ldquo;data-&amp;rdquo; 之后必须有至少一个字符 2. 属性值可以是任意字符串
注释：用户代理会完全忽略前缀为 &amp;quot;data-&amp;quot; 的自定义属性。  好处
通过data-可以自定义属性,可以通过HTMLElement.dataset获取这些属性的值,data-中-后接自定义属性的名字,例如data-url。实际开发中可以利用这一点在生成DOM结构时把数据储存在自定义属性中,通过一系列交互操作,可以再获得这些数据,而不用再去ajax去后台取得数据。</description>
    </item>
    
    <item>
      <title>CSS动画</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/css%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Tue, 26 Feb 2019 15:41:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/css%E5%8A%A8%E7%94%BB/</guid>
      <description>CSS动画 CSS动画主要是有transition属性完成的，animation属性是解决transition属性中遇到的一些问题。动画的实质就是某些css样式随时间的变化可以慢慢改变，不再是以前那种即时完成的，跟时间没关系。现在跟时间有关系，让仍感觉到是一幅动画。
transition transition： [ none | &amp;lt;single-transition-property&amp;gt; ] || &amp;lt;time&amp;gt; || &amp;lt;single-transition-timing-function&amp;gt; || &amp;lt;time&amp;gt;    transition-property ：检索或设置对象中的参与过渡的属性 transition-duration：检索或设置对象过渡的持续时间 transition-timing-function ：检索或设置对象中过渡的动画类型 transition-delay ：检索或设置对象延迟过渡的时间   &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; .test{ width: 100px; height: 100px; border:1px solid; transition: width 1s cubic-bezier(.11,.88,.25,-0.91), background 1s 1s ease-out } .test:hover{ width: 400px; background: red; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  使用注意点 （1）目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀。</description>
    </item>
    
    <item>
      <title>HTML与XHTML区别</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/html%E4%B8%8Exhtml%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/html%E4%B8%8Exhtml%E5%8C%BA%E5%88%AB/</guid>
      <description>HTML与XHTML区别 HTML(文本标记语言)是英文HyperText Markup Language的简称，用于创建网页的标准标记语言，html并不是编程语言，HTML 运行在浏览器上由浏览器来解析翻译给网站访客，它是建设网站的基础。
XHTML(可扩展标识语言)是The Extensible Markup Language的简写,XHTML1.0是源自W3C的最新的HTML标准，是Web的语言。
功能区别：
HTML对于各大浏览器兼容性较差(pc端浏览器、手机端浏览器、PAD)，对于网页页面编写技巧要求比较高，现在web前端开发的静态网页，一般都是html4.0，HTML5就另当别论了。
XHTML可以很好处理各大浏览器的兼容(pc端浏览器、手机端浏览器、PAD),XHTML的语法较为严谨，XHTML结合了部分XML的强大功能及大多数HTML的简单特性。
书写习惯区别
 HTML标签不区分大小写XHTML所有标签都必须小写。 XHTML标签必须成双成对。 html对标签顺序要求不严格，XHTML标签顺序必须正确。 XHTML 文档必须拥有根元素  总而言之xhtml比html更加规范</description>
    </item>
    
    <item>
      <title>渐进式渲染</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%B8%B2%E6%9F%93/</guid>
      <description>渐进式渲染 渐进式渲染（详情）就是一开始先加载首屏显示的内容，之后再随着时间或者滚动页面才进行后面的加载。</description>
    </item>
    
    <item>
      <title>浏览器的标准模式和怪异模式</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 25 Feb 2019 14:18:32 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F/</guid>
      <description> 浏览器的标准模式和怪异模式 现代的浏览器一般都有两种渲染模式：标准模式和怪异模式。
在标准模式下，浏览器按照HTML与CSS标准对文档进行解析和渲染；
而在怪异模式下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。
其实归根结底就是，浏览器如何能将旧网页与新网页区分开来。
标准模式与怪异模式的区别:
  #### 盒模型    图片元素的垂直对齐方式： 对于inline元素和table-cell元素，标准模式下vertical-align属性默认取值为baseline，在怪异模式下，table单元格中的图片的vertical-align属性默认取值为bottom，因此在图片底部会有及像素的空间。
 table 元素中的字体 CSS中，对于font的属性都是可以继承的，怪异模式下，对于table元素，字体的某些元素将不会从body等其他封装元素中继承得到，特别是font-size属性。
 内联元素的尺寸： 标准模式下，non-replaced inline 元素无法自定义大小
怪异模式下，定义这些元素的width，height属性可以影响这些元素显示的尺寸。
 元素的百分比高度： a：CSS中对于元素的百分比高度规定如下：百分比为元素包含块的高度，不可为负值，如果包含块的高度没有显示给出，该值等同于auto，所以百分比的高度必须在父元素有高度声明的情况下使用。
  b：当一个元素使用百分比高度时，标准模式下，高度取决于内容变化，怪异模式下，百分比高度被正确应用。
 #### 元素溢出的处理： 标准模式下，overflow取默认值visible，在怪异模式下，该溢出会被当做扩展box来对待，即元素的大小由其内容决定，溢出不会裁减，元素框自动调整，包含溢出内容。  </description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Sun, 24 Feb 2019 21:36:22 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/%E9%97%AD%E5%8C%85/</guid>
      <description>闭包 阮一峰学习闭包
闭包的概念 高程上关于闭包的定义：闭包是指有权访问另一个函数作用域中的变量的函数
简单理解就是：定义在一个函数内部的函数
在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
创建闭包的方式：在一个函数内部创建另一个函数
function f1(){ var n=999; function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999  其中f2( )就是一个闭包能够访问它上一级函数f1()中的变量n。
闭包关于作用域链的图示：
闭包的用途 1、读取其他函数内部的变量
2、让这些变量的始终保持在内存中，这是一个双刃剑，可以方便的访问内部的变量，即使函数执行完成，其内部变量还保存在内存中可以访问，但是也会带来一系列的问题，外部函数的作用域链和变量对象不能销毁，占用内存。
来看一个典型的例子
var result = new Array(); function createFunctions(){ for (var i=0; i &amp;lt; 10; i++){ result[i] = function(){ console.log(i); }; } } result[6](); //10  从表面上看，似乎每一个函数都返回10 ，但实际上，每个函数都返回10， 因为每个函数的作用域链中都保存着父级函数的活动对象，他们的引用的都是同一个变量i，当父级函数return result 后，变量i的值变成10 ，每个函数引用保存变量i的同一个变量对象，因为此时i=10，所以引用变量指向的值都变成10。
解决这个问题最方便的一个方法是将闭包函数立即执行，每次引用都变成实际i对应的值。每次循环立即执行后销毁引用变量。
var result = new Array(); function createFunctions(){ for (var i=0; i &amp;lt; 10; i++){ result[i] = function(){ var c = i; return function () { console.</description>
    </item>
    
    <item>
      <title>flex布局</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/flex%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sat, 23 Feb 2019 15:41:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/flex%E5%B8%83%E5%B1%80/</guid>
      <description>关于CSS3的flex布局，阮一峰的两篇讲解十分到位！
阮一峰 &amp;amp; Flex 布局教程：语法篇
阮一峰 &amp;amp; Flex 布局教程：实例篇
一、Flex布局是什么？ Flex是Flexible Box的缩写，意为&amp;rdquo;弹性布局&amp;rdquo;，用来为盒状模型提供最大的灵活性！
任何一个容器都可以指定为Flex布局。
.box{ display: flex; }  行内元素也可以使用Flex布局。
.box{ display: inline-flex; }  Webkit 内核的浏览器，必须加上-webkit前缀。
.box{ display: -webkit-flex; /* Safari */ display: flex; }  基本概念 采用Flex布局的元素，称为Flex容器（flex container），简称&amp;rdquo;容器&amp;rdquo;。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&amp;rdquo;项目&amp;rdquo;。
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。
基本语法 容器的六个基本属性：  flex-direction  决定主轴的方向
flex-direction: row(默认值,主轴为水平方向，起点在左端) | row-reverse(主轴为水平方向，起点在右端) | column(主轴为垂直方向，起点在上沿) | column-reverse(主轴为垂直方向，起点在下沿);
 flex-wrap  定义，如果一条轴线排不下，如何换行。
flex-wrap: nowrap(默认，不换行) | wrap(换行，第一行在上方) | wrap-reverse（换行，第一行在下方）;  flex-flow flex-direction属性和flex-wrap属性的简写形式</description>
    </item>
    
    <item>
      <title>Position</title>
      <link>https://zhengxiaomengmeng.github.io/2019/02/position/</link>
      <pubDate>Fri, 22 Feb 2019 15:41:50 +0800</pubDate>
      
      <guid>https://zhengxiaomengmeng.github.io/2019/02/position/</guid>
      <description>position定位 position属性值 参考http://www.cnblogs.com/theWayToAce/p/5264436.html
static （静态定位）：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）
relative （相对定位）：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。　absolute （绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &amp;ldquo;left&amp;rdquo;, &amp;ldquo;top&amp;rdquo;, &amp;ldquo;right&amp;rdquo; 以及 &amp;ldquo;bottom&amp;rdquo; 属性进行规定。可通过z-index进行层次分级。
fixed （固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 &amp;ldquo;left&amp;rdquo;, &amp;ldquo;top&amp;rdquo;, &amp;ldquo;right&amp;rdquo; 以及 &amp;ldquo;bottom&amp;rdquo; 属性进行规定。可通过z-index进行层次分级。
fixed很适合用于固定某个div或者侧边栏在页面中不随页面滚动而滚动。
关于absolute与relative之间的区别，详细可以参考原文</description>
    </item>
    
  </channel>
</rss>